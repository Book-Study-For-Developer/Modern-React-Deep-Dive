#11장 Next.js 13 과 리액트 18

Next.js 버전 13은 React18 을 채택했고, 레이아웃 지원, 웹팩을 대체할 Turbpack 등 주목해야할 내용들이 많다.  Next.js 13이 기존 Next.js의 어떤 점을 개선했는 지 살펴보자.

```tsx 
function App(){
	return(
		<Routes>
			<Route path="/" element={<Layout/>}>
				<Route path="/user" element={<UserPage/>}
				<Route path="/books" element={<BookPage/>}
			</Route>
		</Routes>
	)
}

function Layout(){
	return(
		<div>
			{/*... 공통 부분 들어감 */}
			<Outlet/>
		</div>
	)
}

```
react router dom에서 위와 같이 공통부분 Layout 이 있는 구조를 Next.js 에서 구현하기 위해서는 Next.js 12 의 _app 을 사용해야했고, 페이지 별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족하다 .
## 11.1 app 디렉터리의 등장

Next.js 13 부터 app 디렉토리 내부의 폴더명이 라우팅 된다. 

### layout.js
- layout.{ js | jsx | ts | tsx } 
- 레이아웃 이외의 목적으로 사용이 불가하다.
- 루트에는 단 하나의 layout을 만들 수 있다. layout은 모든 페이지에 영향을 미치는 공통 레이아웃
-  \_document 폴더가 없어짐으로써 \_document에서 진행하던 CSS-in-JS 의 초기화도 layout 파일에서 진행하는 식으로 변경되었다.
### page.js
- 이전의 Next.js 에서 다뤘던 페이지를 의미
- params, searchParams 를 props 로 받는다. search params 에 의존적인 작업을 할 때는 반드시 page 내부에서 수행해야 한다.
### error.js
- 라우팅 영역에서 사용되는 공통 에러 컴포넌트
- 에러바운더리는 클라이언트에서만 작동하기 때문에, 클라이언트 컴포넌트여야한다.
- 에러 정보, 에러 바운더리 초기화할 reset 함수를 props로 받는다 
- layout 에서 발생한 에러를 처리하려면 상위 컴포넌트의 error 를 사용해서 처리해야한다.
### not-found.js
- 404 페이지를 랜더링할 때
- 서버 컴포넌트로 구성
### loading.js
- Suspense 기반으로 컴포넌트가 불러오는 중일 때 사용하는 컴포넌트
### route.js
- /app/api 를 기준으로 디렉터리 라우팅을 지원한다.
- REST API get, post와 같은 메서드명을 예약어로 선언했을 때, HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동
```tsx
export async function GET(request, context: { params }) {
	const team = params.team // '1'
}
```

## 11.2 리액트 서버 컴포넌트
리액트 18에서 도입된 리액트 서버 컴포넌트 !== 서버 사이드 랜더링

**리액트 컴포넌트와 서버 사이드 랜더링의 한계**
- 타사의 라이브러리를 이용을 피하기 어렵고, 자바스크립트 번들이 0 인 컴포넌트를 만들기 어렵다. 
- 백앤드 리소스에 대한 직접적인 접근이 불가능하다. 
- 자동 코드 분할( 코드를 여러 작은 단위로 나누어서 동적으로 지연 로딩하며 앱을 초기화 하는 속도를 높여주는 기법 )이 불가능 하다. 
- 복잡한 추상화 : 클라이언트에서 어떤 정보를 가져와서 보여준다고 할때, import, useEffect, API 호출은 복잡하지만 결과물은 단순할 수도 있다.
리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제이다. 

|               | 장점              | 단점                 |
| ------------- | --------------- | ------------------ |
| 정적 서버 사이드 랜더링 | 서버에서 백앤드 리소스 접근 | 다양한 사용자 경험 어려움     |
| 리액트, Next.js  | 다양한 사용자 경험      | 느리고, 데이터 가져오기 어렵다. |
이 둘의  장점을 취하는 것이 서버 컴포넌트 이다.

컴포넌트는 3가지 종류로 구분된다. 

**1. 서버 컨포넌트**
하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 랜더링할 수 있는 기법
- effect 나 state 에 의존하지 않고 서버에서 제공할 수 있는 기능을 하용하는 훅은 사용이 가능하다.
- 서버에서 실행되기 때문에 DOM API 를 쓰거나 window, document 등에 접근할 수 없다.

**2. 클라이언트 컴포넌트**
- 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
- 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.

**3. 공용 컴포넌트**
- 서버와 클라이언트 모두에서 사용할 수 있다. 서버컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트
- 리액트는 모든 컴포넌트를 공용 컴포넌트로 파악한다. 

리액트 서버 컴포넌트 제안 문서에서 Next.js 와 같은 한 개 이상의 프레임워크 티뫄 리액트 서버 컴포넌트의 초기 구축을 휘해 노력을 기울있음을 언급했다. 

**서버 사이드 랜더링과 서버컴포넌트의 차이**
- 서버 사이드 랜더링
	- 응답받은 페이지 전체를 서버에서 랜더링해서 클라이언트에 내려줌 > 그 후 하이드레이션 과정을 거쳐서 결과물에 이벤트를 붙이는 작업을 수행함
- 서버 컴포넌트
	- 서버에서 클라이언트로 JSON 형태로 결과를 보낸다. > 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있게 도와준다. 

## 11.3 Next.js 에서의 리액트 서버 컴포넌트

## 11.4 웹팩의 대항마, 터보팩의 등장 (beta)

## 11.5 서버 액션(alpha)

## 11.6 그 밖의 변화 

## 11.7 Next.js 13 코드 맛보기

## 11.8 정리 및 주의사항