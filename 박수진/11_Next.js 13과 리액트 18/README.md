#11장 Next.js 13 과 리액트 18

Next.js 버전 13은 React18 을 채택했고, 레이아웃 지원, 웹팩을 대체할 Turbpack 등 주목해야할 내용들이 많다. Next.js 13이 기존 Next.js의 어떤 점을 개선했는 지 살펴보자.

```tsx
function App(){
	return(
		<Routes>
			<Route path="/" element={<Layout/>}>
				<Route path="/user" element={<UserPage/>}
				<Route path="/books" element={<BookPage/>}
			</Route>
		</Routes>
	)
}

function Layout(){
	return(
		<div>
			{/*... 공통 부분 들어감 */}
			<Outlet/>
		</div>
	)
}

```

react router dom에서 위와 같이 공통부분 Layout 이 있는 구조를 Next.js 에서 구현하기 위해서는 Next.js 12 의 \_app 을 사용해야했고, 페이지 별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족하다 .

## 11.1 app 디렉터리의 등장

Next.js 13 부터 app 디렉토리 내부의 폴더명이 라우팅 된다.

### layout.js

- layout.{ js | jsx | ts | tsx }
- 레이아웃 이외의 목적으로 사용이 불가하다.
- 루트에는 단 하나의 layout을 만들 수 있다. layout은 모든 페이지에 영향을 미치는 공통 레이아웃
- \_document 폴더가 없어짐으로써 \_document에서 진행하던 CSS-in-JS 의 초기화도 layout 파일에서 진행하는 식으로 변경되었다.

### page.js

- 이전의 Next.js 에서 다뤘던 페이지를 의미
- params, searchParams 를 props 로 받는다. search params 에 의존적인 작업을 할 때는 반드시 page 내부에서 수행해야 한다.

### error.js

- 라우팅 영역에서 사용되는 공통 에러 컴포넌트
- 에러바운더리는 클라이언트에서만 작동하기 때문에, 클라이언트 컴포넌트여야한다.
- 에러 정보, 에러 바운더리 초기화할 reset 함수를 props로 받는다
- layout 에서 발생한 에러를 처리하려면 상위 컴포넌트의 error 를 사용해서 처리해야한다.

### not-found.js

- 404 페이지를 랜더링할 때
- 서버 컴포넌트로 구성

### loading.js

- Suspense 기반으로 컴포넌트가 불러오는 중일 때 사용하는 컴포넌트

### route.js

- /app/api 를 기준으로 디렉터리 라우팅을 지원한다.
- REST API get, post와 같은 메서드명을 예약어로 선언했을 때, HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동

```tsx
export async function GET(request, context: { params }) {
  const team = params.team; // '1'
}
```

## 11.2 리액트 서버 컴포넌트

리액트 18에서 도입된 리액트 서버 컴포넌트 !== 서버 사이드 랜더링

**리액트 컴포넌트와 서버 사이드 랜더링의 한계**

- 타사의 라이브러리를 이용을 피하기 어렵고, 자바스크립트 번들이 0 인 컴포넌트를 만들기 어렵다.
- 백앤드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할( 코드를 여러 작은 단위로 나누어서 동적으로 지연 로딩하며 앱을 초기화 하는 속도를 높여주는 기법 )이 불가능 하다.
- 복잡한 추상화 : 클라이언트에서 어떤 정보를 가져와서 보여준다고 할때, import, useEffect, API 호출은 복잡하지만 결과물은 단순할 수도 있다.
  리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제이다.

|                         | 장점                        | 단점                            |
| ----------------------- | --------------------------- | ------------------------------- |
| 정적 서버 사이드 랜더링 | 서버에서 백앤드 리소스 접근 | 다양한 사용자 경험 어려움       |
| 리액트, Next.js         | 다양한 사용자 경험          | 느리고, 데이터 가져오기 어렵다. |

이 둘의 장점을 취하는 것이 서버 컴포넌트 이다.

컴포넌트는 3가지 종류로 구분된다.

**1. 서버 컨포넌트**
하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 랜더링할 수 있는 기법

- effect 나 state 에 의존하지 않고 서버에서 제공할 수 있는 기능을 하용하는 훅은 사용이 가능하다.
- 서버에서 실행되기 때문에 DOM API 를 쓰거나 window, document 등에 접근할 수 없다.

**2. 클라이언트 컴포넌트**

- 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
- 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.

**3. 공용 컴포넌트**

- 서버와 클라이언트 모두에서 사용할 수 있다. 서버컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트
- 리액트는 모든 컴포넌트를 공용 컴포넌트로 파악한다.

리액트 서버 컴포넌트 제안 문서에서 Next.js 와 같은 한 개 이상의 프레임워크 티뫄 리액트 서버 컴포넌트의 초기 구축을 휘해 노력을 기울있음을 언급했다.

**서버 사이드 랜더링과 서버컴포넌트의 차이**

- 서버 사이드 랜더링
  - 응답받은 페이지 전체를 서버에서 랜더링해서 클라이언트에 내려줌 > 그 후 하이드레이션 과정을 거쳐서 결과물에 이벤트를 붙이는 작업을 수행함
  - 목적 : 초기에 인터렉션은 불가능 하지만 정적 HTML를 빠르게 내려주는데 초점
  - HTML을 로딩한 후에 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는 데 비용이 든다.
- 서버 컴포넌트
  - 서버에서 클라이언트로 JSON 형태로 결과를 보낸다. > 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있게 도와준다.
  - 아직은 베타이다.

**두가지 모두 채택**
이후 서버사이드 랜더링과 서버컴포넌트를 모두 채택하는 것이 가능해질 예정이다.

- 서버컴포넌트를 활용해서 서버에서 랜더링할 수 있는 컴포넌트는 서버에서 완성해서 제공을 받을 것이다.
- 클라이언트 컴포넌트는 서버사이드 랜더링을 이용해서 HTML으로 빠르게 전달 받을 것이다.
- 즉 이둘은 대체제가 아닌 상호보완하는 개념

**서버 컴포넌트의 작동**

1. 서버가 랜더링 요청을 받는다. 서버컴포넌트를 사용하는 모든 페이지는 서버에서 시작되고, 루트 컴포넌트도 항상 서버 컴포넌트이다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON 으로 직렬화 한다
   - 서버에서 랜더링 할 수 있는 부분은 직렬화 ( 와이어 포맷 M: 클라이언트 컴포넌트, S: Suspense, J: App.server.js )
   - 클라이언트 컴포넌트 표시된 부분은 플레이스 홀더 형식으로 비워두고 나타낸다.
3. 브라우저는 서버로 부터 스트리밍으로 JSON 결과물을 받으면 -> 이를 파싱해서 트리를 재구성해 -> 컴포넌트를 랜더링하고 브라우저의 DOM 에 커밋할 것이다.

## 11.3 Next.js 에서의 리액트 서버 컴포넌트

리액트 팀은 서버 컴포넌트를 온전히 사용하기 위해 번들러와 프레임워크의 도움이 필수라고 언급했다.
Next.js 도 13버전에서 서버 컴포넌트를 도입했고 /app 디렉토리에 구현되어있다.

**Next.js 에 도입된 리액트 서버 컴포넌트 특징**
리액트 컴포넌트에서 서버컴포넌트와 큰 차이가 없고, 몇가지 다른 부분이 있는 데, 다음과같다.

- 과거 Next.js 의 서버사이드 랜더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getInitialProps가 /app 내부에서 삭제되고 모든 데이터 요청을 fetch API 기반으로 이뤄지는 부분
  - 서버사이드 랜더링이 아니어도 서버에서 데이터를 직접 불러올 수 있다.
  - 컴포넌트가 비동기적으로 데이터가 불러와지면 페이지를 랜더링해서 클라이언트로 전달하는 것도 가능해진다
  - 추가로 fetch API 가 요청 중복되는 것도 방지했다.
- 정적 랜더링과 동적 랜더링
  - fetch option 으로 데이터 캐싱 여부를 결정하며
  - generateStaicParams 를 사용해 과거 Next.js 의 getStaticPaths 를 흉내 낼수도 있다.
- fetch 의 데이터를 캐싱하고, revalidate 변수를 선언해서 특정 시간이 지났을 때 갱신하도록 설정할 수 있다.
  - 서버에서 루트부터 데이터를 전체적으로 가져와 갱신함으로 브라우저나 react 의 state 의 영향을 미치지 않음
- 스트리밍을 활용해 점진적인 페이저 불러오기
  - 과거 서버사이드 랜더링은 랜더링 요청받은 페이지를 모두 랜더링 할때 까지 사용자는 빈페이지를 보게 되었다.
  - 이를 해결하기 위해 HTML 을 작게 쪼개서 완성되는 대로 보내고, 사용자는 일부라도 페이지와 인터랙션을 할 수 있게 된다.
  - 핵심 웹 지표인 TTFB(최초 바이트까지의 시간), FCP(최초 콘텐츠풀 페인팅)을 개선하는 데 큰 도움을 준다.
  - 이 스트리밍을 활용하기 위해 loading.tsx 를 배치 하거나 리액트 Suspense 컴포넌트를 배치하면 된다.
  - 로딩이 끝난 컴포넌트 순서대로 하이드레이션을 수행하면서 사용자가 빠르게 상호작용한 페이지를 제공한다.

## 11.4 웹팩의 대항마, 터보팩의 등장 (beta)

- Rome, SWC, esbuild 는 기존 자바스크립트로 만들어져 제공되던 기능을 Rust 나 go 같은 언어를 활용함으로 자바스크립트 대비 월등히 뛰어난 성능을 보여준다
- Turbopack 역시 러스트 기반으로 작성되어 웹팩 대비 700배 빠르다고 소개되며 안정화되어 정식버전이 출시될 것을 기대하고 있다.

## 11.5 서버 액션(alpha)
Next.js 13 에서 선보인 서버액션은 API를 생성하지 않고 함수 수준에서 서버에 직접 접근해 데이터 요청을 수행할 수 있는 기능이다.
- next.config.js 에서 실험기능을 활성화 해야한다.
- 'use server' 지시자를 선언하고, async 로 함수를 작성해야한다.
- 다음과 같은 작업을 수행할 수 있다.
  - form의 action
    - 현재 라우트 주소와 ACTION_ID 를 보내면 서버에서 실행할 내용을 찾아 직접 실행한다.
    - 이 모든 과정이 페이지 새로고침 없이 수행된다.
    - form을 기반으로 데이터 추가 및 수정을 좀더 자연스럽게 수행
  - input의 submit 과 image의 form action
  - startTransition 과의 연동
  - server mutation 이 없는 작업
- 주의 점 

## 11.6 그 밖의 변화

## 11.7 Next.js 13 코드 맛보기

## 11.8 정리 및 주의사항
