# 4\_서버 사이드 랜더링

## 4.1 서버 사이드 랜더링이란?

### 싱글 페이지 애플리케이션 (SPA) 는 뭐야?

#### Single Page Application

- 랜더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 페이지 전환( 라우팅 ) : history.pushState, history.replaceState 로 이뤄진다.
  - 새로운 HTML 페이지를 요청하는게 아니라 다음페이지의 랜더링에 필요한 정보만 HTTP 요청 등으로 가져와서 DOM 을 추가, 수정, 삭제 하는 방법으로 페이지가 전환 된다.
- 페이지를 불러온 이후에는 서버에서 HTML 을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다.
  - 실제 소스보기 하면, HTML <body> 태그 안에 아무런 정보가 없다. 내부 내용도 자바스크립트로 삽입하고 랜더링 되기 때문이다.
- 단점
  - 최초 로딩해야 할 자바스크립트 리소스가 커진다.
- 장점
  - 한번 로딩된 이후에는, 페이지 전환에 필요한 일부 영역만 다시 그리면 되기때문에 서버를 거쳐 필요한 리소스를 받아올 일이 적어져 훌륭한 UI/UX 를 제공할 수 있다.

#### 전통적 방식의 애플리케이션과 SPA 비교하기

- 전통적 방식
  - 페이지 전환이 될때, 새롭게 페이지를 요청한다. HTML 페이지를 다운로드해서 파싱한다.
    - 브라우저 환경이 충분히 빠르지 못하면, 흰화면이 잠시 노출되는 깜빡임 등으로, 불편한 사용자 경험을 제공할 수 있다.
      - 따라서 이부분을 보완한, SPA 의 매끄러운 UI로 근래 웹페이지들이 SPA 방식을 채택한것
  - 예시
    - https://www.w3.org/

#### SPA 의 유행과 JAM 스택 등장

- SPA 가 유행하기 까지
  - PHP, JSP( JavaServer Pages)
    - 새로운 페이지 요청시: 서버에서 완성된 HTML을 받는 서버사이드 랜더링
    - 자바스크립트는 사용자에게 추가적인 경험을 주기위한 보조수단
  - 자바스크립트가 할 수 있는 일 이 점점 다양해짐
    - 자바스크립트 모듈화
      - CommonJS 와 AMD(Asynchronous Module Definition) 등장으로, 파일 분할 및 더 복잡한 앱 구현이 쉬워졌다.
    - 기기 성능의 향상
    - 인터넷 속도 발전
  - 2010년 : Backbone.js, AngularJS, Knockout.js 등Mvx 프레임워크 등장
    - 서버에서하던 복잡한 일을 클라이언트 단에서 하기 시작하면서, 프레임 워크 등장
  - React, Vue, Angluar 의 시대
    - 랜더링 부터 인터랙션까지 자바스크립트로
- 스택 발전
  - LAMP 스택
  - 서버 의존적인 구조는
    - 클라우드가 보편적이지 않았던 이 당시 걸림돌이었다. 웹어플리케이션의 기능이 다양해지고, 사용자가 늘어나면, 서버도 확장을 해야만 했다.
    - Linux(운영체제), Apache(서버), MySQL(데이터베이스), PHP/Python 등 구성
  - JAM 스택
    - Javascript, API, Markup
    - 자바스크립트와 Markup( HTML, css )을 미리 빌드해두고 정적으로 제공한 후, 이후 작동은 모두 사용자의 클라이언트에서 API 를 이용해 실행 - MEAN , MERN 스택
    - MEAN( MongoDB, Express.js, AngularJS, Node.js )
      MERN( MongoDB, Express.js, React , Node.js )
  - Node.js 의 고도화에 힘입어, API 서버자체도 자바스크립트로 구현하는 구조가 인기

#### 새로운 패러다임의 웹서비스를 향한 요구

- SPA 의 유행으로 웹 애플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가하기 시작했다.
- 그와 함께 프로세서, 메모리 등 하드웨어성능의 발전, 그리고 인터넷 속도 증가도 일어났다.
  - 웹페이지의 속도는 얼마나 개선이 되었나?
    - https://httparchive.org/reports/loading-speed
      - 모바일 환경에서의 웹페이지 로딩과 인터랙션은 여전히 오래걸린다.
      - 자바스크립트 파싱을 위해 CPU 를 소비하는 시간이 눈에 띄게 증가했다.
  - 결론: 실제 사용자들이 느끼는 웹 애플리케이션의 로딩 속도는 크게 차이가 없거나 더 느리다
    - 사용자의 기기와 인터넷 속도 등 웹 전반의 환경이 개선 됐음에도, 그만큼 웹의 기능이 복잡해졌고, 리소스의 크기가 커졌다는 거다.

### 서버사이드 랜더링 (SSR) 이란?

#### SSR?

- SPA 가 웹페이지가 느려지는 상황에, 기존 방식의 웹 개발이 다시금 떠오르고 있다.
- 서버사이드 랜더링은 랜더링에 필요한 작업이 모두 서버에서 실행된다.

#### 서버 사이드 렌더링의 장점

- 최초 페이지 진입이 비교적 빠르다. 
  - 첫 페이지 진입시 유의미한 정보가 그려지는 시간 ( First Contentful Paint ) 가 빨라질 수 있다. 
  - SPA: 페이지 집입 > 자바스크립트 리소스 다운 > HTTP 요청의 응답 결과로 화면 렌더링
  - 서버에서 랜더링을 제공할 수 있는 충분한 리소스가 확보되어있다면 
  - 서버에서 HTTP 요청을 수행하는 것이 빠르다
  HTML 을 문자열로 미리 그려서 주는 것이 클라이언트 기존 HTML 에 삽입하는 것 보다 더 빠르다 
  - HTTP 요청에 의존적인 화면, 랜더링해야 할 HTML의 크기가 커진다면 SSR 이 더 빠를 수 있다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
  - 검색엔진 정보수집 과정
    1. 페이지 진입
    2. 페이지의 HTML 을 다운로드
    3. 페이지 내부의 오픈 그래프나 메타 태그정보를 기반으로 페이지의 검색(공유) 정보를 가지고와서 검색엔진에 저장
    - 로봇은 자바스크립트를 실행하지 않으며, 정적 정보를 검색 정보로 가져옴
  - SPA 는 자바스크립트의 작동에 의존하기 때문에, 페이지 진입시 메타 정보를 제공할 수 있게 조치를 해줘야한다
  - SSR 의 경우 검색엔진에 필요한 정보를 서버에서 가공해서 HTML 응답으로 제공이 가능해서 검색엔진 최적화에 대응하기가 용이하다.
- 누적 레이아웃 이동이 적다.
  - 누적 레이아웃 이동( Cumulative Layout Shift ) : 사용자에게 페이지를 보여준 이후 뒤늦게 어떤 HTML 정보가 추가 삭제 되며 화면이 덜컥거리는 것 같은 부정적인 사용자 경험을 말함
    - 예시: 광고 배너사진이 뒤늦게 로딩되며, 게시글이 원래 위치에서 밀린다거나 하는 현상
  - SSR은 이런 요청들이 완료된 후의 페이지를 제공하므로 이런 문제에서 자유로울 수 있다.
    - 문제: 모든 요청이 완료되기 까지 페이지가 랜더링 되지 않으니, 최초 페이지 다운로드가 느려지는 것 아닌가? 이는 리액트 18의 스트림으로 해결할 수도 있다고 한다.
- 사용자 디바이스 성능에 비교적 자유롭다.
  - 자바스크립트 리소스의 실행은 사용자의 디바이스에서 실행됨으로 디바이스 성능에 의존적이다! 모바일에서 페이지 로딩이 느린 이유가 있다.
  - 서버사이드 랜더링을 수행하면 이런 부담을 서버에 나누어서 디바이스 성능으로 부터 조금 더 자유로워 질 수 있다.
    - 단, 사용자 방문의 폭증으로 서버에 부담이 가중되고, 이를 위한 처리가 수반되지않으면, SSR 도 느려질 것이다.
- 보안에 좀 더 안전하다.
  - 브라우저의 개발자 도구에서 API 호출, 인증 등 사용자에게 노출되면 안되는 민감한 작업도 볼 수 있다. 따라서 정상적인 비지니스 로직이 아닐때, API 호출되는 것을 방지 해야한다.
  - 서버사이드 랜더링의 경우 인증이나 민감한 작업을 서버에서 수행하고 결과를 브라우저에 제공함으로 보안 위협을 피할 수 있다.

#### 서버 사이드 랜더링의 단점

- 소스코드를 작성할 때 항상 서버를 고려해야 한다. - 브라우저에만 있는 전역객체 window 또는 sessionStorage 같은 경우 해당 코드가 서버사이드에서 처리되지 않고, 클라이언트에서만 실행되게 처리해야한다. 이는 외부 의존 라이브러리에도 해당된다.
  클라이언트에서만 실행되어야하는 코드가 늘어나면 SSR 의 장점이 줄어든다.
- 적절한 서버가 구축돼 있어야 한다.
  - 사용자의 요청을 받아 랜더링을 수행할 서버가 필요
    - - 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량 확보
- 장애 대응 복구 전략
- 요청 분산 및 다운 대비 프로세스 매니저
- 여러 도구 : 쿠버네티스 등 필요
- 서비스 지연에 따른 문제
  - SPA 는 느린 작업이 있을 때, 로딩 중 같이 안내 UI 를 표시해주면 되지만, SSR 은 랜더링 작업이 끝날 때까지 정보 제공 불가해 더 안좋은 사용자 경험을 제공할 수 있다.

#### SPA 와 SSR을 모두 알아야하는 이유

##### 서버사이드 랜더링은 만능이 아니다

- 웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇이고, 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계 후 SPA 와 SSR 중 적절히 선택하자
- 잘못된 설계는 서버와 클라이언트 두 군데로 관리 포인트만 늘어나게 한다.

##### 싱글 페이지 애플리케이션과 서버 사이드 랜더링 애플리케이션

- 뛰어난 SPA > 뛰어난 SSR
  SPA의 매끄러운 라우팅 경험을 SSR 이 따라올 수 없다. - Gmail 이 그런 완성도 높은 SPA 의 예이다.
  - 최초 페이지 진입시 보여줘야할 정보만 최적화 랜더링
  - 중요도가 떨어지는 리소스는 게으른 로딩
  - 코드 분할(필요한 코드만 나눠서 번들링)로 불필요한 자바스크립트 리소스 다운로드 및 실행 방지
- 평균적 SPA < 평균적 SSR
  매 요청마다 비슷한 성능의 랜더링을 수행하는 SSR 이
  최적화가 안되어 디바이스에 따른 사용자 경험이 좋지 않을 수 있는 SPA 보다 나을 수 있다. 또한 SSR 의 라우팅 문제를 해결하기 위한 API가 브라우저에 추가되고 있다. - SSR 의 라우팅 문제를 해결하기 위한 API 를 보자.
  - 페인트 홀딩 : 같은 출처에서 라우팅이 일어나면 화면을 하얗게 띄우지만 이전 페이지를 보여주는 기법
  - back forward cache : 브라우저 앞으로 뒤로가기시 캐시된 페이지를 보여주기
  - shared element transition : 두 페이지에 동일 요소가 있을 때, 콘텍스트 유지해 부드럽게 전환되게하기
- 어느 하나 완벽한 것이 없으며 둘다 발전 중에 있다.

##### 현대의 서버 사이드 랜더링

- Next.js 와 Remix와 같은 요즘 서버사이드 랜더링 프레임워크는 최초 웹사이트 진입시에 서버사이드 랜더링으로 HTML 을 제공받고 이후 라우팅에서는 SPA 처럼 작동한다.
  - LAMP 에서는 모든 페이지를 서버에서 랜더링 함으로 라우팅이 느렸다.

### 정리

SPA 와 SSR 의 라우팅과 랜더링 방식을 잘 이해해야 각 장점을 제대로 취해서 다수의 사용자에게 좋은 사용자 경험을 제공하는 웹 애플리케이션을 만들 수 있다.

## 4.2 서버 사이드 랜더링을 위한 리액트 API 살펴보기

### 리액트 서버사이드 랜더링

- react-dom/serve.js : 리액트 애플리케이션을 서버에서 랜더링 할 수 있는 기본 API 를 제공하고 있다.
- 최초 HTML 페이지를 빠르게 그려주는 데 목적
- 사용자와 인터랙션할 준비가 되기 위해서는 이와 관련된 별도의 자바스크립트 코드를 모두 다운로드, 파싱, 실행하는 과정이 필요함

#### 기본 함수

##### render 함수

- renderToString
  - 인수로 넘겨 받은 리액트 컴포넌트를 HTML 문자열로 반환하는 함수
  - div#root 에 존재하는 data-react-root 속성은 자바스크립트를 싱행하기 위해 hydrate 함수에서 루트를 식별하는 기준점이 됨.
- renderToStaticMarkup
  - renderToString 과 매우 유사하게 리액트 컴포넌트를 기준으로 HTML 문자열을 만드는데, 다른점은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다. hydrate 수행하지 않는다는 가정하에 순수한 HTML 만 반환한다.
    - HTML 크기를 줄일 수 있다는 장점이 있다.
  - 언제 사용되나?
    - 리액트의 이벤트 리스너가 필요없는 순수한 HTML 을 만들때 사용된다.
    - 블로그 글과 같이 아무런 브라우저 액션이 없는 정적인 내용인 경우 유용하다.
- renderToNodeStream
  - renderToString 과 결과물은 동일하고 두가지 차이점이 있다.
    - 위의 두 함수는 브라우저에서도 실행할 수 있는데. 이 함수는 Node.js 환경에 완전히 의존함으로 브라우저에서 사용하는 것이 불가능 하다.
    - 결과물이 Node.js 만 사용할 수 있는 ReadableStream (utf-8로 인코딩 되어있는 바이트 스트림) 이다. string 을 얻기 위해서는 추가적인 처리가 필요하다.
  - 스트림
    - 큰 데이터를 다룰 때 데이터를 청크로 분할해 조금씩 가져오는 방식
  - 언제 사용 되나?
    - HTML 의 크기가 매우 클 때, 작은 단위로 분리되어 연속적으로 작성됨으로 HTML 파일이 완성될때 까지 기다릴 필요가 없으며, Node.js 의 서버 부담을 덜 수 있다.
      - Q. 이거는 한번 직접 chuck 를 확인해보면 될것 같은데, 작은 단위로 분리되어 전달을 받았을 때, 클라이언트 단에서 어떻게 하나로 연결하는걸까? 가장 처음 받는 chuck 는 독립적으로 랜더링이 가능한 청크고, 이후의 청크들을 추가적을 랜더링을 하는 것일까?
    - 예시: todo app의 todos 가 매우 많은 경우, 대부분의 널리 알려진 SSR 랜더링 프레임워크들이 renderToNodeStream 을 채택하고 있다고 한다.
- renderToStaticNodeStream
  - renderToStaticMarkup 과 유사하게 renderToNodeStream 의 순수 HTML 을 반환하는 함수 버전이다.

##### hydrate

- renderToString, renderToNodeStream 에서 생성된 정적인 HTML에 이벤트와 핸들러를 붙여 완전한 웹페이지 결과물을 만듬
- 브라우저에서만 사용되는 메서드 render 와 유사

  - 차이

    ```tsx
    ReactDOM.render(<App />, rootElement);
    ReactDOM.hydrate(<App />, rootElement);
    ```

    - 이둘의 차이는 rootElement에 있다. render 는 비어있는 HTML 을 넘겨받고 랜더링도 진행하고 hydrate 는 이미 랜더링된 HTML 에서 이벤트나 핸들러를 추가한다.
    - 서버에서 랜더링한 정보가 없으면 경고발생 하지만, 정상적으로 웹페이지를 생성한다. hydrate 도 랜더링을 하면서, HTML 인수로 넘겨받은 HTML 비교하는데, 불일치하면, hydrate 가 랜더링한 기준으로 랜더링 한다. 이렇게 되면, 서버와 클라이언트 각각 두번씩 랜더링해서 결국 서버사이드 랜더링의 장점을 포기하는 것이다.

      ```tsx
      	//경고예시
      	// 서버에서 계산한 시간과, hydrate에서 계산한 시간이 다르면 불일치 경고가 발생한다.
      	<div>{new Date().getTime()} </div>

      	//다음과 같이 불일치 경고를 제거한다
      	<div suppressHydrationWarning>{new Date().getTime()} </div>
      ```

          - 시간의 경우 useEffect 를 통해 클라이언트 통해서 보이게 하고, 서버에서는 함수가 실행되지 않게 하는 것이 정확할 것

### 서버 사이드 랜더링 예제 프로젝트

## 4.3 Next.js 톺아보기

### 4.3.1 Next.js 란?

### 4.3.2 Next.js 시작하기

### 4.3.3 Data Fetching

### 4.3.4 스타일 적용하기

### 4.3.5 \_app.tsx 응용하기

### 4.3.6 next.config.js 살펴보기

### 4.3.7 정리
