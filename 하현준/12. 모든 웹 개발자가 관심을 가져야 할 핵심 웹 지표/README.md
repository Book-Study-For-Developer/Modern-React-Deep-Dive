## 1. 웹사이트와 성능

웹사이트의 성능과 사용자 경험 사이의 상관관계

- 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율이 2.5배 높다
- 0 ~ 5초의 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다.
- 페이지 로딩 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성
- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다
- 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝힘.

개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나기 때문에 이러한 문제를 대체로 느끼지 못한다.

또한, 네트워크 환경도 안정적이기 때문에 성능 문제를 경험하기 어렵다.

구글은 **핵심 웹 지표(Core Web Vital)**라고 하는, 웹사이트의 우수한 사용자 경험을 제공하는데 필요한 몇 가지 핵심적인 요소를 꼽고 제시하고 있다.

## 2. 핵심 웹 지표란?

웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어이다.

**핵심 웹 지표**

- 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)
- 최초 입력 지연(FID: First Input Delay)
- 누적 레이아웃 이동(CLS: Cumulative Layout Shift)

**특정 문제 진단을 위한 지표**

- 최초 바이트까지의 시간(TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

# 3. 최대 콘텐츠풀 페인트(LCP)

### 정의

페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간을 말한다.

뷰포트는 사용자에게 현재 노출되는 화면을 의미하는데 그중 큰 이미지와 텍스트는 다음과 같다.

- <img>
- <svg> 내부의 <image>
- posster속성을 사용하는 <video>
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텏트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소

### 의미

측정하는 기준이 DOMContentLoaded 이벤트가 호출되는 시간이라고 생각하지만 ‘스타일시트’, ‘이미지’, 하위 프레임의 로딩은 기다리지 않는 제한이 있기 때문에 무리가 있다.

단순히 사용자에게 있어 노출되는 부분만 로딩돼 잇다면 사용자는 페이지가 로딩이 완료됐을 것이라 느낄 것이다. 그러므로 **뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 측정하면 된다.**

### 기준 점수

2.5초 내로 응답이 오면 좋고 4초 이내는 보통 그이상은 나쁨으로 판단된다.

### 개선 방안

- 텍스트는 언제나 옳다.
- 이미지는 어떻게 불러올 것인가? background-image 대신 img 태그를 사용하자
- 그 밖에 조심해야할 사항
  - 이미지 무손실 압축
  - loading=lazy 주의: 그저 로딩속도만 늦출 뿐 지표 점수에는 도움이 되지 않기에 LCP이미지에서는 사용하지 않는 것이 좋다.
  - fadein과 같은 각종 애니메이션: 애니메이션을 사용하면 LCP도 그만큼 늦어진다.
  - 클라이언트에서 빌드하지 말 것: 서버에서 가능하면 미리 빌드된 채로 오는 것이 좋다.
  - 최대 콘텐츠풀 리소스는 직접 호스팅: 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야하기 때문에 좋지 않다.

## 4. 최초 입력 지연(FID)

### 정의

웹페이지의 반응성을 측정하는 지표이다.

사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정한다.

### 의미

개발자들은 사용자의 입력을 고의로 막거나 지연시키지 않는다. 내부에 어떠한 원인때문에 반응이 늦어지기 떄문인데, 대부분 브라우저의 메인 스레드가 바쁘기 때문이다.

대규모 렌더링, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문이다.

구글은 사용자 경험을 크게 4가지로 분류해 정의했다.

- **Response**: 사용자의 입력에 대한 반응 속도, 50ms미만으로 이벤트를 처리할 것
- **Animation**: 애니메이션 각 프레임을 10ms 이하로 생성할 것
- **Idle**: 유효 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- **Load**: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것

이는 **RAIL**이라고 부르며 FID는 R에 초점을 맞추고 있다.

### 기준 점수

100ms 이내로 응답이 와야 좋은 점수를 얻을 수 있고, 300ms 이내인 경우 보통, 그 이후는 나쁨으로 처리된다.

### 개선 방안

**실행에 오래 걸리는 긴 작업을 분리**

- 꼭 웹페이지에서 해야 하는 작업인가: 크롬 개발자 도구에서 네트워크 속도를 감속 시킨후에 테스트해본 뒤에 웹페이지에서 작업해야 하는 작업인지 고민해 봐야 한다.
- 긴 작업을 여러 개로 분리하기: 하나의 긴 작업이 메인 스레드를 계속 점유할 수록 사용자는 페이지에서 응답을 받지 못하고 있을 가능성이 크다. 그렇기에 여러 개로 분리하는 것이 좋다.

**자바스크립트 코드 최소화**

**크롬 개발자 도구 > 도구 더보기 > 커버리지** 를 사용해서 웹페이지에서 사용되지 않은 코드가 얼마나 있는지 확인할 수 있다. 여기서 확인된 코드들은 특정 이벤트에 따라 실행되는 코드, 예기치 못한 상황에서 실행될 코드 등 다양한 것들이 존재할 수 있는데 지연 로딩이나 우선순위를 낮춰서 불러오는 것이 좋다.

또 폴리필을 봐야 하는데, 인터넷 익스플로러 11 이하 버전에서는 지원하지 않는 메서드(Array.prototype.find)를 위해 꽤 용량이 큰 코드가 들어가진다. → Jquery 4.0에서도 이를 제거함

다음을 먼저 확인해보자

- 폴리필이 필요한 환경인가?
- 꼭 필요한 폴리필인가?

**타사 자바스크립트 코드 실행의 지연**

Google Analytics나 Firebase와 같이 타사 스크립트를 넣는 경우 사용자에게 안 좋은 반응성을 제공해줄 수 있다. 이러한 스크립트는 `async`와 `defer`를 이용해 지연 불러오기를 사용하는 것이 좋다.

**→ 저희 회사에서도 이 때문에 타사 스크립트는 `async`를 항상 넣어줍니다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/253d1ac1-0c8d-4179-8d90-21ade38e0aea/e2175651-e4db-4e8f-bf99-34278552151d/Untitled.png)

## 5. 누적 레이아웃 이동(CLS)

### 정의

**페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것**이 바로 누적 레이아웃 이동(CLS)라고 한다.

### 의미

useEffect는 렌더링이 한 번 끝난 이후에 콜백 실행하는 훅이다. UI의 레이아웃을 변경하는 작업이 있다면 콘텐츠의 위치가 밀리거나 요소의 위치가 바뀌어 상호작용을 실패하게 된다. 이는 CLS 에 좋지 못하는 점수를 받을 가능성이 커진다.

단순히 요소가 추가된다고 해서 무조건 CLS로 간주 되는 것은 아니다. **요소가 추가됐다 하더라도 다른 요소의 시작 위치에 영향을 미치지 않았다**면 레이아웃 이동으로 간주되지 않는다.

또, 사용자 액션으로 인해 발생한 레이아웃 이동은 점수에 포함되지 않는다. 점수를 계산할 때 포함되는 내용은 다음과 같다.

- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미한다. 예를 들어, 레이아웃 이동이 발생한 요소의 높이가 10이고, 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔다고 가정하면 뷰포트 높이(100)중 20을 영향을 미쳤으므로 영향분율은 0.2점이다.
- 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미한다. 예를 들어, 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔고, 전체 뷰포트가 100이라면 0.1점이 된다.

최종 점수는 둘을 곱해 계산한다. (0.02점)

### 기준 점수

0.1 이하인 경우 좋음, 0.25 이하인 경우 보통, 그 외에는 개선이 필요한 나쁜 점수

### 개선 방안

**삽입이 예상되는 요소를 위한 추가적인 공간확보**

useEffect의 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업을 최소화하는 것이 좋다. useEffect사용이 불가피하다면 useLayoutEffect 훅을 검토해보자.

또는 **스켈레톤 UI를 사용하여 무언가가 동적으로 뜰 것으로 예상**되는 공간을 미리 확보해두는 것도 좋은 방법이다.

가장 좋은 방법은 서버 사이드 렌더링을 사용해서 서버에서 미리 판단하여 클라이언트에 내려주는 방법이다.

**폰트 로딩 최적화**

폰트로 인해 발생할 수 있는 문제는 다음 두가지이다.

- **FOUT(flash of unstyled text)**: HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
- **FOIT(flash of invisible text):** HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

아래 블로그도 비슷한 얘기를 하기에 블로그로 대체합니다.

**웹 폰트 사용과 최적화의 최근 동향:** https://d2.naver.com/helloworld/4969726

**적절한 이미지 크기 설정**

```css
img {
  width: 100%;
  height: auto;
}
```

이렇게 설정한 css의 경우 CLS가 커진다. 이미지가 다운로드 되기 전까지 알 수 없기 때문에 이미지 높이를 높게 잡아 뒀다가 이미지가 완전히 로드 된 뒤에 자리 잡게 된다. 따라서 CLS가 크게 발생한다는 단점이 있다.

- width, height 지정: width와 height를 지정하는 것이 가장 좋은 방법이다. CLS를 방지해주고 aspect-ratio로 인해 자동으로 비율도 맞춰준다.

```tsx
export default function App() {
  return (
    <div className="App">
      <img src="/image.jpg" alt="이미지" width="1600" height="900" />
    </div>
  );
}
```

- 만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우, 즉 반응형 이미지를 사용하고 싶다면 srcset 속성을 사용하는 것이 좋다.

```tsx
<img
  width="1600"
  height="1000"
  src="image-1000.jpg"
  srset="image=1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
  alt="이미지"
/>
```

### 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

**최초 바이트까지의 시간(Time To First Byte, TTFB)**

브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미한다. 즉, 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 **최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표**다.

이는 서버 사이드 렌더링을 하고 있는 곳에서 중요한 지표인데, 사용자가 페이지를 요청했을 때 빈 화면이 뜨는 것은 사용자 경험을 저해한다.

- 서버사이드 렌더링을 수행하고 있다면
  - 로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다. getServerSideProps함수의 실행과 그 결과에 따른 정적 페이지 렌더링이 될 것이다.
  - API 호출이 필요하다면 호출 횟수와 가져오는 정보의 크기를 최소화해서 빠르게 하고 크기를 가능한 줄여야 한다.
- 웹페이지의 주된 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋다. 아마존의 경우 한국 사용자에게는 **`us-east-*`** 보다 **`ap-*(아시아)`** 그리고 이보다 가까운 **`ap-northeast-2(서울)`**이 낫다.

**최초 콘텐츠풀 페인트(First Contentful Paint, FCP)**

페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다. 즉, **웹사이트에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간을 의미**한다.

FCP를 개선하려면 다음과 같은 사항을 고려해야 한다.

- **TTFB를 개선**: 렌더링을 최대한 빠르게 하기 위해 최초 바이트까지의 시간을 단축해야 한다.
- **렌더링을 가로막는 리소스 최소화**: 자바스크립트나 CSS같은 렌더링을 가로막는 리소스를 최소화하고 렌더링을 방해하는 리소스를 비동기적으로 로드하도록 해야 한다.
- **Above the Fold에 대한 최적화**: ‘Above the Fold’란 신문이 독자에게 제공됐을 때 가장 먼저 보이는 영역을 일컫는 말이다. 웹페이지에서는 스크롤을 굳이 하지 않아도 보이는 영역을 말한다.
  useEffect와 같이 의존되어 요소가 렌더링 되는 것을 피하고, 게으른 로딩이나 스크립트에 의존하는 것들은 모두 FCP에 도움이 되지 않는다.
- **페이지 리다이렉트 최소화**: 리다이렉트는 없거나 최소한으로 유지해야 한다.
- **DOM 크기 최소화**: DOM이 복잡하고 크다면 그만큼 렌더링되는 데 시간이 오래 걸린다. 구글에 따르면 전체 DOM 노드는 1500개 미만, 깊이는 32단계 정도, 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 한다.
