# 상태와 상태 관리

## 상태의 필요성

- 상태는 애플리케이션에서 지속적으로 변경될 수 있는 값을 나타낸다.
- 웹 애플리케이션에서는 UI, URL, 폼, 서버에서 가져온 값 등 다양한 상태가 존재한다.

## 웹 애플리케이션에서의 상태 분류

- **UI:** 다크/라이트 모드, 각종 Input 값, 알림창의 노출 여부 등
- **URL:** 브라우저에서 관리되는 상태값으로 사용자의 라우팅에 따라 변경됨
- **폼(form):** 로딩 여부, 제출 상태, 값의 유효성 등
- **서버에서 가져온 값:** 서버로 요청을 통해 가져온 데이터

# Flux 패턴의 등장

- **MVC 패턴**은 모델과 뷰가 복잡해질수록 복잡성이 증가한다는 문제가 있었다. 모델과 뷰가 서로 간섭하고 양방향 통신을 하면서 코드의 유지보수가 어려워지는 문제가 발생했다.
- 이를 해결하기 위해 **Flux 패턴** 두두등장!

## Flux 패턴의 도입

- Flux 패턴은 단방향 데이터 흐름을 강조하여 데이터의 변화를 추적하기 쉽게 만들어졌다.
- 이 패턴은 페이스북에서 개발한 패턴으로, 데이터의 흐름이 한 방향으로만 흐르도록 하는 아키텍처를 제공한다.

## Flux Architecture

- **Action:** 애플리케이션에서 일어나는 어떤 작업을 나타내는 객체로, 액션 발생 시 함께 전달되는 데이터를 포함한다.

- **Dispatcher:** 액션을 스토어로 전달하는 역할을 합니다. 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.

- **Store:** 애플리케이션의 상태를 저장하고, 상태에 따라 값을 반환하거나 상태를 변경할 수 있는 메서드를 가지고 있다.

- **View:** 사용자에게 보여지는 부분으로, 스토어에서 가져온 데이터를 이용하여 화면을 렌더링하고 사용자의 입력을 감지하여 액션을 발생시키기도 한다.

Flux 패턴은 단방향 데이터 흐름으로 데이터를 추적하기 쉽게 만들어주며, 리액트와의 조합이 매우 자연스럽게 이루어지게 된다.

# 상태 관리 라이브러리의 등장

## Redux

- **Redux**는 하나의 상태 객체를 스토어에 저장하고, 디스패치를 통해 이 객체를 업데이트한다.
- 전역 상태 객체를 사용하여 상태를 하위 컴포넌트에 전파할 수 있으며, 이는 props drilling을 해결하는 데 도움이 된다. 그러나 보일러플레이트의 양이 많아 사용이 번거롭다.

## Context API

- **Context API**는 상태를 주입해주는 기능을 제공한다.
- props를 넘기지 않아도 Context Provider가 주입하는 상태를 사용할 수 있다. 그러나 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능은 없다.

## React Query와 SWR

- **React Query**와 **SWR**은 외부에서 데이터를 불러오는 데 특화된 라이브러리로, HTTP 요청에 특화된 상태 관리를 제공한다.

## useState와 useReducer

- **useState**의 등장으로 리액트에서는 간단하게 동일한 인터페이스의 상태를 생성하고 관리할 수 있다.
- 하지만 지역 상태의 한계가 존재하며, 컴포넌트마다 초기화되어 컴포넌트별로 다른 상태를 가진다.

# 상태 관리 라이브러리의 동작 방식

- 상태 관리 라이브러리는 **useState**와 **useReducer**의 한계를 극복하기 위해 외부에 상태를 둔다.
- 이 외부 상태 변경을 감지하고 컴포넌트의 렌더링을 일으켜 상태를 전파한다.

# 상태 관리 라이브러리 살펴보기

## Recoil

- **Recoil**은 최상단에 스토어를 만들고, **Atom**이라 불리는 최소 상태 단위를 등록하여 사용한다.
- 컴포넌트는 Recoil에서 제공하는 훅을 통해 Atom의 상태를 구독하고, 값이 변경되면 리렌더링을 실행한다.
- 비동기 작업을 쉽게 처리할 수 있는 API를 제공하며, 별도의 미들웨어 없이도 비동기 작업이 가능하다.

## Jotai

- **Jotai**는 Recoil의 영감을 받아 만들어진 라이브러리로, 불필요한 리렌더링을 최소화하고 메모이제이션을 필요로 하지 않게 설계되었다.
- 별 다른 세팅이 필요없고 사용하기 굉장히 쉽다는 장점이 있다.

## Zustand

- **Zustand**는 하나의 중앙 스토어를 활용해 상태를 관리한다.
- 코드 양이 적고 빠르게 스토어를 생성하고 사용할 수 있는 특징이 있다.
- 리덕스와 함께 사용 가능한 여러 미들웨어를 지원하며, 상태를 간단하게 정의할 수 있어 가볍고 편리하다.
