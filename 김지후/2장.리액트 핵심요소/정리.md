# JSX

- 트리 구문 작성 문법
- 트랜스파일을 거쳐 자바스크립트(ECMAScript)로 변경

### **JSXElement**

- HTML 요소와 유사
- `<div>`, `<button>`, `<h1>` 등의 태그를 사용할 수 있음
- 사용자 정의 가능

### **JSXAttributes**

- **HTML의 속성과 유사합니다.**
- **`className`, `id`, `style` 등의 속성을 가질 수 있음**

### **JSXChildren**

- **SXElement 내부의 내용**
- **다른 JSXElements, 문자열, 숫자, 배열 등이 될 수 있음**

### **JSXStrings**

- **JSX 요소 내부의 문자열**

# 가상 DOM

## 브라우저 렌더링 과정

- HTML파일로 DOM 구성 → CSS 파일로 CSSOM 구성 → DOM을 순회하면서 CSS 적용(reflow, painting)

## 가상 DOM

- 메모리에 저장됨. 실제 렌더링 시에만 DOM에 반영
- react-dom 라이브러리

### 파이버

- 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있음. JavaScript 객체
- 내부적으로 쪼개진 **‘작업’의 단위**, 이는 작업 단위로 우선순위를 조절해서 처리할 수 있게 함
  → **비동기 렌더링 매커니즘**
  → 렌더링 도중 사용자 입력을 받고, 애니메이션도 처리할 수 있게 함
  → 기존의 Stack Reconciler의 동기적 처리, 느린 단점을 보완
- 실행 시점: state 변경, 생명주기 메서드 실행, DOM 변경이 필요한 시점

### 재조정

- 가상 DOM과 실제 DOM을 비교하는 알고리즘
- 렌더링이 필요한 부분을 추적하는 것

### 리액트 파이버 트리

- `Current 트리`: 현재 트리
- `WorkingInProgress(이하 WIP) 트리`: 작업 중인 상태를 나타내는 트리, 사용자에게 노출되지 않음
- `더블 버퍼링`: 말 그대로 두 개의 버퍼를 사용한다. 하나는 실제 화면에 보이는 UI 상태를 나타내고, 하나는 변경 예정인 새로운 상태를 나타낸다.

### 동작 방법

- **상태 업데이트 → WIP 트리 빌드 → 렌더링 → Current를 WIP로 교체**

### 파이버 작업 순서

- DFS: 자식Fiber, 형제Fiber, 부모Fiber 순서로 탐색함
- 동일한 레벨에 있는 list 태그의 경우 sibling으로 참조된다.

# 클래스형 🆚 함수형

### 클래스형 컴포넌트의 한계

- 데이터 흐름을 추적하기 어렵다. 생명주기 메서드가 너무 많음
- 애플리케이션 내부 로직의 재사용이 어렵다. 함수형의 경우 합성(HoC) 방식으로 관리
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다 (동의)

### 함수형 컴포넌트 🆚 클래스형 컴포넌트

- 함수형 컴포넌트
  - 렌더링된 값을 고정함
  - 생명주기 메서드의 부재
- 클래스형 컴포넌트
  - 자식 컴포넌트에서 발생한 에러 처리?

# 리액트 렌더링

<aside>
💡 왜, 언제 일어나는지 알아야 최적화 할 수 있다

</aside>

### 렌더링 발생 시점

1. 최초 렌더링
2. 리렌더링
   1. 클래스형 컴포넌트의 setState
   2. 클래스형 컴포넌트의 forceUpdate
   3. 함수형 컴포넌트의 useState → setter
   4. 함수형 컴포넌트의 useReducer → dispatch
   5. key props
   6. pops
   7. **부모 컴포넌트가 리렌더링 되는 경우**

### 렌더와 커밋

- 렌더
  - 컴포넌트 렌더링(**리액트 렌더링**) 결과 수집 및 변경 사항 계산
  - type, props, key의 변경사항 확인
- 커밋
  - 실제 DOM에 적용
- 브라우저 렌더링

⇒ **리액트 렌더링≠ 브라우저 렌더링**, 리액트 렌더링이 수행되어도 커밋 단계가 생략되면 브라우저 렌더링으로 연결되지 않는다.

# 메모이제이션

<aside>
💡 얕은 비교 비용 vs 재렌더링 비용

</aside>

### 꼭 필요한 경우에만

- 발생할 수 있는 문제
  - 렌더링 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
  - 리액트가 구 트리와 신규 트리를 비교

### 싹 다!

- 발생할 수 있는 문제
  - 메모이제이션 수행 비용 증가(값 비교, 렌더링, 재계산 등)

⇒ 참조 투명성, 일반적인 경우 재렌더링 비용이 높으므로 **섣부른 메모이제이션 최적화**를 시도해보자!
