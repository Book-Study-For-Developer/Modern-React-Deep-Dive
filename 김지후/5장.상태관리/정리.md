# 상태 관리란?

- 상태
  - 어떠한 의미를 지닌 값으로 **애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값**
  - UI, URL, 폼, 서버에서 가져온 값
- 상태 관리
  - 상태를 어디에 둘 것인지 / 전역 변수 / 클로저 / 상태 유효 범위 / 이를 자식 요소들이 구독하도록 하는 것 등
  - 애플리케이션의 복잡성을 관리하기 위함
- 상태 관리의 역사
  - flux / redux / Context API, useContext / React Query, SWR / Recoil, Zustand, Jotai, Valito

# 리액트 훅으로 시작하는 상태 관리

# 상태 관리 라이브러리

## Recoil

## Jotai

- 상향식(bottom-up). 가장 작은 단위인 atom이 필요에 따라 더 조합되기도 하면서, 더 큰 단위의 상태로 확장되어 가는 방식
- Recoil과 동일하게 atom을 최소 단위로 하지만 이에서 **파생된 상태**까지 만들 수 있음
- API 호출 처리도 깔끔하네요. https://jotai.org/docs/guides/async

### Jotai 예제: 파생된 상태를 사용하기

- '파생된 상태'라는 개념이 특정 상태를 구독하고, 업데이트하는 로직을 줄여주는 것 같아 특정 시나리오에 유용하게 쓰일 것 같습니다.
- 아래는 사용자 언어 설정에 따라 i18n 관련 변수를 파생된 상태로 생성하는 코드입니다.

```ts
export const locale_atom = atom<LocaleName>(_locale || "en"); // 'ko-KR'
export const i18n_atom = atom((get) => new I18N(get(locale_atom))); // lang에 맞는 텍스트, 날짜, 시간, 숫자 등의 표시 방식을 제공
export const lang_atom = atom((get) => get(i18n_atom).lang); //  'ko'
```

### Jotai 예제: localStorage와 연동해 영구적으로 데이터 저장

- localStorage 사용이 필요한 경우(테마, 언어 같은 사용자 설정 / 장바구니 등) 편리해 보입니다.
- 아래는 localStorage에서 테마 정보를 가져오는 예제입니다.

```jsx
import { atomWithStorage } from "jotai/utils";
import { useAtom } from "jotai";
import { useEffect } from "react";

// 테마 설정을 저장하는 아톰을 생성합니다. 초기값으로 'light'를 사용합니다.
const themeAtom = atomWithStorage("theme", "light");

function ThemeSwitcher() {
  const [theme, setTheme] = useAtom(themeAtom);

  // 테마 설정에 따라 body의 class를 변경합니다.
  useEffect(() => {
    document.body.className = theme;
  }, [theme]);

  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light");
  };

  return (
    <button onClick={toggleTheme}>
      Switch to {theme === "light" ? "dark" : "light"} theme
    </button>
  );
}
```

-> 전반적으로 간편하고 깔끔하다는 인상을 주는데 복잡한 예외처리가 붙어야 하거나 유즈케이스가 조금만 복잡해져도 로직이 분산화돼서 읽는 입장에서 피로하지 않을까?라는 생각도 드네요.

## Zustand

- 리덕스와 유사하게 하나의 스토어를 중앙 집중형으로 관리
- 미들웨어 지원
- https://ui.toast.com/weekly-pick/ko_20210812
