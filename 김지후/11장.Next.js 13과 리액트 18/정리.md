# 1. app 디렉터리

## 1-1. 라우팅

- 기존의 파일 시스템 기반 라우팅을 유지하지만, 관련 파일을 정의하던 디렉터리 명이 `/pages`에서 `/app`으로 변경되었다.
- 파일명으로 라우팅하는 것이 불가능해졌다.
  - 페이지 라우팅: `/pages/a/b.tsx`, `/pages/a/b/index.tsx`는 모두 동일한 주소로 변환된다.
  - app 라우팅: `/app/a/b`는 `/a/b`로 변환되며, 파일명은 무시된다. 폴더명만 주소로 변환된다.

다음은 라우팅 파일명에 대한 컨벤션이다.

### layout.js

- 공통 레이아웃을 적용할 수 있는 파일이다.
- [children](https://nextjs.org/docs/app/api-reference/file-conventions/layout#children-required)을 props로 받아서 렌더링해야 한다. ➕ fallback 컴포넌트 자체로 쓰이는 [loading](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states), [error](https://nextjs.org/docs/app/building-your-application/routing/error-handling)의 경우 예외다.
- 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- **API 요청과 같은 비동기 작업을 수행할 수 있다.**
- **하위 폴더 및 주소에 모두 영향을 미친다.**

➕ app 디렉터리에는 layout이 반드시 정의되어 있어야 하며([Root Layout](https://nextjs.org/docs/app/api-reference/file-conventions/layout#root-layouts)), <html>, <body>를 반드시 포함해야 한다.

다음은 app 라우팅 결과를 확인할 수 있는 간단한 예제다.

```
/app
├── layout.tsx
└── /dashboard
    └── layout.tsx
```

```tsx
// app/layout.tsx

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

```tsx
// app/dashboard/layout.tsx

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <section>{children}</section>;
}
```

아래와 같은 구조로 렌더링 된다.

```tsx
<html lang="en">
  <body>
    <section>...</section>
  </body>
</html>
```

- **기존에 \_document에 선언했던 styles-components의 초기화 방식**

### page.js

- 앞서 정의한 layout을 기반으로 page에 정의된 컴포넌트를 노출한다.
- 마찬가지로 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- props
  - `[params(opt)](https://nextjs.org/docs/app/api-reference/file-conventions/page#params-optional)`: [slug]와 같은 동적 라우트 파라미터를 받는다.
  - `[searchParams(opt)](https://nextjs.org/docs/app/api-reference/file-conventions/page#searchparams-optional)`: ?a=1과 같은 URLSearchParams를 받는다. [searchParams의 경우 layout에서는 제공되지 않으므로](https://nextjs.org/docs/app/api-reference/file-conventions/layout#layouts-do-not-receive-searchparams) `page.js`나 클라이언트 컴포넌트에서 `useSearchParams`를 사용해야 한다.

```tsx
export default function Page({
  params,
  searchParams,
}: {
  params: { slug: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  return <h1>My Page</h1>;
}
```

### error.js

- 공통 에러 컴포넌트를 정의할 수 있다.
- [결과적인 계층 구조](https://www.notion.so/Modern-React-Deep-Dive-Next-js-13-18-001c42baa5e0410e90572425bd50cf02?pvs=21)에 따라 같은 수준의 레이아웃에서 발생한 에러는 처리할 수 없다.
  - 루트 에러 처리에는 `[global-error.js](https://nextjs.org/docs/app/api-reference/file-conventions/error#global-errorjs)` 페이지를 사용할 수 있다.
- `ErrorBoundary`가 클라이언트에서만 작동하므로 `use client`를 명시해 클라이언트 컴포넌트로 작성해야 한다.

```tsx
"use client"; // 클라이언트 컴포넌트

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // 에러 로깅
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

<aside>
➕ [어떻게 동작할까?](https://nextjs.org/docs/app/building-your-application/routing/error-handling#how-errorjs-works) 
error.js는 자동으로 `ErrorBoundary`를 생성하여 page.js를 감싸는 위치에 출력된다. 이때 error.js에 쓰인 컴포넌트가 fallback용으로 사용된다. ErrorBoundary 내부에서 에러가 발생한 경우 fallback이 출력되고, 그 외부는 정상적으로 유지되고 인터랙션이 가능하며, 에러 컴포넌트는 에러에서 복구될 수 있는 화면을 출력한다.

</aside>

### not-found.js

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링한다.
- 전체 애플리케이션에 대해 노출하고 싶다면 `app/not-found.js`를 생성하면 된다.

### loading.js

- Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용된다.

### route.js

- 특정 라우팅 주소에 대한 custom request handler를 작성할 수 있다.
- 메서드명을 예약어로 선언해 두면 HTTP 요청에 맞게 작동한다.
- api 폴더가 아닌 다른 곳(e.g. `apps/internal-api/hello/route.ts`)에 선언해도 작동한다. 이 경우 당연히 page.tsx가 존재할 수 없다.
- `request`: fetch의 request가 확장된 NextRequest 객체다.
- `context`: params만을 가지고 있으며 동적 라우팅 파라미터가 포함되어 있다.

```tsx
// /api/hello/route.ts

export async function GET(request: Request) {}

export async function HEAD(request: Request) {}

export async function POST(request: Request) {}

export async function PUT(request: Request) {}

export async function DELETE(request: Request) {}

export async function PATCH(request: Request) {}

// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and  set the appropriate Response `Allow` header depending on the other methods defined in the route handler.
export async function OPTIONS(request: Request) {}
```

```tsx
export async function GET(request, context: { params }) {
  const team = params.team; // '1'
}
```

➕ 위의 특정 파일들에 정의된 컴포넌트는 다음과 같은 계층 구조를 가지게 된다.

[https://nextjs.org/docs/app/building-your-application/routing#component-hierarchy](https://prod-files-secure.s3.us-west-2.amazonaws.com/e63eafe2-0c35-402a-99b0-0097a1ef8cdf/c0cfd9ee-d0ab-41d6-b658-c098e4e0054b/component-hierarchy.avif)

https://nextjs.org/docs/app/building-your-application/routing#component-hierarchy

# 2. 리액트 서버 컴포넌트

## 2-1. 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

1. 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
2. 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
3. 자동 코드 분할(code split)이 불가능하다.
4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
5. 추상화에 드는 비용이 증가한다.

## 2-2. 서버 컴포넌트란?

<aside>
➕ 요즘 IT, 새로 등장한 ‘서버 컴포넌트’ 이해하기: https://yozm.wishket.com/magazine/detail/2271/
카카오페이, React 18: 리액트 서버 컴포넌트 준비하기: https://tech.kakaopay.com/post/react-server-components/

</aside>

- `서버 컴포넌트`
  - 요청이 오면 서버에서 한 번만 실행되므로 React API 사용이 제한적이다. hook, 렌더링 생명주기 뿐만 아니라 브라우저 API도 사용할 수 없다.
  - 데이터베이스, 내부 서비스, 파일 시스템 등 서버 데이터를 async/await 없이 접근할 수 있다. 컴포넌트 자체가 async한 것이 가능하다.
  - 번들에 포함되지 않는다.
  - **client boundaries**
    - **부모 자식 간에 따라 결정되는 것이 아니라, 호출 루트에 따라 결정된다?**
  - **‘컴포넌트 내에 서버 전용 코드를 실행할 방법이 생겼다.’는 것으로 이해하면 된다?**

리액트는 기본적으로 모든 것을 다 `공용 컴포넌트`로 판단한다. 이는 서버 컴포넌트일 수도, 클라이언트 컴포넌트일 수도 있음을 의미한다. 특정 경우에 한해 클라이언트 컴포넌트로 해석한다.

- `클라이언트 컴포넌트`
  - 서버 컴포넌트를 불러올 수는 없지만, 자식으로 출력하는 것은 가능하다.
    ```tsx
    'use client'

    import ServerComponent from './ServerComponent.server' // ❌
    export default function ClientComponent() {
    	return (
    		<div>
    			<ServerComponent />
    		</div>
    }
    ```
    ```tsx
    // page.js

    import ClientComponent from "./ClientComponent";
    import ServerComponent from "./ServerComponent";

    export default function Page() {
      return (
        <ClientComponent>
          <ServerComponent /> // ⭕️
        </ClientComponent>
      );
    }
    ```
    위의 경우 이미 렌더링된 결과물로 children에 들어간다.
  - `use client`를 작성하면 서버 컴포넌트를 import하는 시점에 에러를 발생시킨다.

## 2-3. 서버 사이드 렌더링과 서버 컴포넌트의 차이

`서버 사이드 렌더링(SSR)`은 클라이언트가 첫 요청을 보냈을 때, 서버에서 리액트 컴포넌트를 HTML로 렌더링하고 이를 클라이언트에게 보낸다. 이때 SSR로 렌더링된 컴포넌트는 클라이언트에서도 다시 렌더링되고, 이 과정에서 필요한 자바스크립트 파일은 번들에 포함되므로, 클라이언트의 번들 사이즈에 영향을 준다.

`서버 컴포넌트`는 서버에서만 렌더링되며, 그 결과가 HTML로 클라이언트에게 전달된다. 하지만 이 컴포넌트는 클라이언트에서 재렌더링되지 않으며, 자바스크립트 번들에 포함되지 않아 번들 사이즈를 줄일 수 있다

**따라서, 서버 사이드 렌더링과 서버 컴포넌트는 모두 서버에서 렌더링을 수행하지만, 클라이언트에서의 렌더링 방식과 번들 사이즈에 영향을 주는 방식이 다르다.**

저자는 이 둘을 대체제가 아닌 상호보하는 개념으로 보아야 한다고 말한다. 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받고, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 빠르게 전달받을 수 있을 것이다.

## 2-4. 서버 컴포넌트는 어떻게 작동하는가?

- 서버 컴포넌트 데모: https://github.com/reactjs/server-components-demo

- 서버에서 클라이언트로 정보를 보낼 때 **JSON으로 직렬화**하여 스트리밍 형태로 보낸다. 이에 렌더링 속도가 빨라질 수 있다.
  - JSON으로 직렬화 할 수 없는 class나 Date는 전달할 수 없다.
- 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않고 각 컴포넌트별로 번들링이 되어 있어 필요에 **따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능하다**.

# 3. Next.js에서의 리액트 서버 컴포넌트

## 3-1. 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- app 디렉터리 내부에서 getServerSideProps, getStaticProps, getInitialProps가 삭제되었고, 데이터 요청은 **fetch**를 기반으로 이뤄진다.
- 이때 해당 fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

## 3-2. 정적 렌더링과 동적 렌더링

정적인 라우팅에 대해서는 기본적인 캐싱이 지원되고, 동적인 라우팅에 대해서는 요청이 올 때마다 컴포넌트를 렌더링한다.

아래는 캐싱과 관련된 fetch 옵션이다.

- `fetch(URL, { **cache: ‘force-cache’** })`: 기본값으로 `getStaticProps`와 유사하게 불러온 데이터를 캐싱해 해당 데이터로만 관리한다.
- `fetch(URL, { **cache: ‘no-store’** })`, `fetch(URL, { **next: { revalidate: 0** }})`: `getServerSideProps`와 유사하게 캐싱하지 않고 매번 새로운 데이터를 불러온다.
- `fetch(URL, { **next: { revalidate: 10 }**})`: 정해진 유효시간 동안 캐싱하고, 이 유효시간이 지나면 캐시를 파기한다.

## 3-3. 캐시와 mutating, 그리고 revalidating

```tsx
// app/page.tsx
export const revalidate = 60;
```

fetch에 revalidate 옵션을 설정하는 것과 동일하다.

이러한 캐시를 무효화하고 싶다면 `router.refresh()`를 호출할 수 있다. 이 작업은 브라우저나 리액트 state에는 영향을 미치지 않는다.

## 3-4. 스트리밍을 활용한 점진적인 페이지 불러오기

이전의 서버사이드 렌더링은 요청받은 페이지를 한번에 내려줬다면, 이제 **스트리밍을 통해 먼저 완성된 페이지부터 점진적으로 보낼 수 있다.** 이는 핵심 웹 지표인 최초 바이트까지의 시간(TTFB)과 최초 콘텐츠풀 페인팅(FCP)를 개선하는 데 도움을 준다.

스트리밍을 활용하는 방법으로 아래 두가지가 있다.

1. 경로에 [loading.tsx](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)를 배치한다
2. [Suspense](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)를 배치한다. loading은 Suspense를 기반으로 하기 때문에 작동 원리는 동일하며 더욱 세분화된 제어가 가능하다.

   ```tsx
   import { Suspense } from "react";
   import { PostFeed, Weather } from "./Components";

   export default function Posts() {
     return (
       <section>
         <Suspense fallback={<p>Loading feed...</p>}>
           <PostFeed />
         </Suspense>
         <Suspense fallback={<p>Loading weather...</p>}>
           <Weather />
         </Suspense>
       </section>
     );
   }
   ```

# 4. 웹팩의 대항마, 터보팩(beta)

Next에서는 [SWC](https://nextjs.org/docs/architecture/nextjs-compiler) 사용을 공식적으로 권장하고 있다. Next.13에서는 [터보팩](https://nextjs.org/docs/architecture/turbopack)이 출시되었으며 이는 웹팩 대비 700배, vite 대비 10배 빠르다고 하며, 러스트 기반으로 작성됐기 때문에 가능하다고 소개하고 있다.

# 5. 서버 액션(alpha)

## 5-1. form의 action

## 5-2. input의 submit과 image의 formAction

## 5-3. startTransition과의 연동

## 5-4. server mutation이 없는 작업

## 5-5. 서버 액션 사용 시 주의할 점

# 6. 그 밖의 변화

# 7. Next.js 13 코드 맛보기

## 7-1. getServerSideProps와 비슷한 서버 사이드 렌더링 구현해보기

## 7-2. getStaticProps와 비슷한 정적인 페이지 렌더링 구현해보기

## 7-3. 로딩, 스트리밍, 서스펜스
