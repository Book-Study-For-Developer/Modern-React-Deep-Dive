# 12.2 Core Web Vitals

구글에서 제안하는 핵심 웹 지표입니다.

- 최대 콘텐츠풀 페인트(LCP, Largest Contentful Paint)
- 최초 입력 지연(FID, First Input Delay)
- 누적 레이아웃 이동(CLS, Cumulative Layout Shift)

추가로 최초 바이트까지의 시간(TTTB, Time To First Byte), 최초 콘텐츠풀 시간(FCP, First Contentful Paint)도 있습니다.

# 12.3 최대 콘텐츠풀 페인트(LCP)

### LCP, 판단 기준

LCP는 ‘페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간’을 의미합니다. 큰 요소라고 하더라도 뷰포트를 넘어가면 제외됩니다.

- 2.5초 이내: 좋음
- 4초 이내: 보통
- 그 이상: 나쁨

여기서 인식한다는 이미지와 텍스트는 다음과 같이 정의되어 있습니다.

- <img>
- <svg> 내부의 <image>
- poster 속성을 사용하는 <video>
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소(<p>, <div>)

<aside>
💡 image vs svg
그동안 사이즈 변동이 잦으면서도 화질이 중요한 이미지는 svg를 사용해왔는데 LCP 지표에 악영향을 미치는 줄은 몰랐네요.

</aside>

### 개선 방안

이미지보다는 당연히 텍스트가 빠르게 로딩되고, 이미지의 경우 불러오는 방식에 따라 차이가 있습니다.

1. **img 태그**
2. svg 태그
3. **video 태그 + poster 속성**
4. background-image CSS

결과적으로 1, 3번이 가장 빠른데, 이는 브라우저의 프리로드 스캐너에 의해 발견되기 때문에 HTML 파싱 이전에 이미지를 미리 로딩할 수 있기 때문입니다.

그 밖에도 LCP 지표에 있어 주의해야 할 사항들이 존재합니다.

- **이미지 무손실 압축**: 가능한 이미지를 **무손실 형식**으로 압축해 최소한의 용량으로 전달해야 합니다.
- **loading=lazy**: loading=lazy는 해당 리소스의 중요도를 낮춰 필요할 때 로드하는 전략입니다. 해당 속성이 최대 콘텐츠풀 콘텐츠에 걸리면 로딩 속도를 늦춰 지표 점수에 도움이 되지 않습니다.
- **fade in과 같은 애니메이션**: 애니메이션으로 인해 리소스가 늦게 출력된다면 이 역시 지표에 영향을 미칩니다.
- **클라이언트 빌드**: 최적의 시나리오는 서버에서 빌드해온 HTML을 프리로드 스캐너가 읽어 콘텐츠풀 페인트로 빠르게 가져가는 것입니다.
- **최대 콘텐츠풀 리소스는 직접 호스팅**: 외부 이미지를 가져오는 경우 네트워크 커넥션부터 다시 수행해야 하기 때문에 같은 도메인에서 직접 호스팅하는 것이 좋습니다.

# 12.4 최초 입력 지연(FID)

### FID, 판단 기준

FID는 웹사이트의 반응 속도와 관련된 지표입니다. 사용자의 최초의 입력 하나에 대한 응답 시간을 측정합니다.

- 100ms 이내: 좋음
- 300ms 이내: 보통
- 그 이상: 나쁨

측정 대상은 클릭, 터치, 타이핑 등 입력 작업에 해당하며 스크롤이나 핀치 투 줌 등은 제외합니다.

### 개선 방안

FID가 지연된다는 것은 브라우저의 메인 스레드가 오래 점유되고 있다는 것을 뜻합니다. 이 경우 아래의 두가지 방법으로 개선해 볼 수 있습니다.

1. 서버 처리 고려: 정말 클라이언트에서 처리해야 하는 경우가 아니라면 서버로 옮겨 브라우저의 메인 스레드를 오래 점유하지 않게 할 수 있습니다.
2. 긴 작업을 여러개로 분리: 여기서 ‘긴 작업’은 50ms 이상 걸리는 작업을 의미합니다. 이 경우 당장 노출될 필요가 없다면 리액트의 Suspense와 lazy, Next.js의 dynamic 등을 사용해 나중에 불러오도록 처리할 수도 있습니다.
3. 자바스크립트 코드 최소화: 사용하지 않는 코드는 최소화하는 것이 좋습니다. 이는 번들러가 해주는 작업이기도하지만 그 후에도 남아있으면서 실행된 적 없는 코드는 크롬 개발자 도구의 ‘커버리지’를 통해 확인할 수 있습니다. 이는 최초 실행시 필요하지 않다는 사실을 의미하므로 우선순위를 낮춰서 불러올 수 있습니다. 아울러 폴리필의 경우 브라우저 환경에 따라 구형 브라우저를 지원하지 않는다면 대부분의 폴리필을 사용할 필요가 없습니다. 많이 사용되지 않는 폴리필이라면 직접 자바스크립트 코드를 작성하는 것이 코드 크기를 줄일 수 있습니다.
4. 타사 자바스크립트 코드 실행 지연: Google Analytics나 firebase처럼 웹페이지 로드에 중요한 자원이 아니라면 async나 defer를 사용해 로딩을 지연시킬 수도 있습니다. async와 defer 모두 병렬로 다운로드 받는다는 공통점을 지니지만 async는 다운로드 즉시 실행되고, defer는 다운로드가 완료되어도 맨 마지막에 실행됩니다. 이때 광고의 경우라면 Intersection Observer를 이용해 해당 뷰포트에 진입했을 때 불러올 수도 있습니다.

# 12.5 누적 레이아웃 이동(CLS)

### CLS, 판단 기준

CLS는 누적 레이아웃 이동을 의미하며 예기치 않은 이동에 대한 지표를 계산합니다. 예를들어 렌더링 이후 useEffect를 통해 UI의 레이아웃이 변경되었다면 CLS 지표 점수가 올라갑니다. 이때 다른 요소의 시작 위치에 영향을 미치지 않았다면 계산되지 않습니다.

- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미합니다.
- 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미합니다.
- CLS = 영향분율 \* 거리분율

위의 수식을 보면 알 수 있듯이 뷰포트의 영향을 받기 때문에 기기마다 점수가 달라집니다.

- 0.1 이하: 좋음
- 0.25 이하: 보통
- 그 이상: 나쁨

### 개선 방안

1. 삽입이 예상되는 요소를 위한 추가적인 공간 확보: useEffect는 useLayoutEffect로 대체할 수 있고, 스켈레톤 UI처럼 미리 레이아웃을 잡아둘 수도 있습니다. 혹은 서버 사이드 렌더링에서 HTML을 미리 제공하는 방법도 있습니다.
2. 폰트 로딩 최적화: 폰트가 변경되거나 폰트 변경으로 인해 텍스트가 출력되지 않는 경우 누적 레이아웃 이동이 발생할 수 있습니다. 이 경우 폰트를 불러오는 <link> 태그에 preload를 사용해 폰트를 미리 불러와 UI 방해를 줄일 수 있습니다. 또는 font-family에 auto, block, swap, fallback, optional 등의 옵션을 조합해 다운로드 우선순위를 조정하고 이에 실패했다면 적절한 fallback을 구성할 수 있습니다.
3. 적절한 이미지 크기 설정: 이미지 비율을 유지하기 위해 가장 많이 쓰이는 css, `width: 100%, height: auto`는 이미지 사이즈가 뒤늦게 조정되면서 누적 레이아웃 이동을 발생시킵니다. 이는 이미지 사이즈를 구체적으로 작성하되 비율을 맞춰 지정하면 `aspect-ratio` 속성 덕분에 로딩 이전에 사이즈를 맞춰 출력하게 됩니다. 만약 뷰포트 너비에 맞게 이미지 사이즈를 다르게 조절하고 싶다면 `srcset` 속성을 사용할 수 있습니다.

# 그 외의 지표들

- TTFB: 최초 응답이 오는 바이트까지가 얼마나 걸리느지를 측정하는 지표입니다.
- FCP: 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정합니다. 이때 일부에 포함되는 요소는 텍스트, 이미지, svg 등을 의미합니다.
