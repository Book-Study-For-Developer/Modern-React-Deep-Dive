# 1. 상태 관리는 왜 필요한가?

상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미합니다.

웹 애플리케이션에서 상태로 분류될 수 있는 것들 →UI, URL, form, 서버에서 가져온 값입니다.

웹 서비스 기능 ↑ 관리해야할 상태 ↑ :  증가하는 상태를 효과적으로 관리하는 방법을 고민해야 한다.

상태를 관리해야 한다면?

상태를 어디에 둘것인가? , 전역 변수에 둘 것인가? , 별도의 클로저를 만들 것인가? , 그 상태가 유효한 범위는 어떻게 제한할 수 있을까? ,상태의 변화에 따라 변경돼야하는 자식 요소들은 어떻게 이 상태의 변화를 감지할 것인가? , 이러한 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상(Tearing)을 어떻게 방지할 것인가?

→ 이런 고민들 처럼 현재 웹 애플리케이션에서는 상태 관리란 어렵다고 해서 외면할 수 없는 주제가 되었다.

## 리액트 상태 관리의 역사

리액트는 애플리케이션 개발에 모든 것을 제공하는, 이른바 프레임워크를 지향하는 앵귤러와는 다르게 리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐이고 그 이상의 기능을 제공하지 않고 있다.

### FlUX 패턴의 등장

`Flux` 가 등장하기 이전에는 웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추척하고 이해하기가 어려운 상황

2014년, 리액트의 등장과 비슷한 시기에 `Flux 패턴`과 함께 이를 기반으로 한 라이브러리 `Flux`가 소개

기존의 MVC 패턴은 뷰(HTML)가 모델(자바스크립트)을 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경할 수 있습니다. 이는 코드를 작성하는 입장에서는 간단할 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워집니다. -> 페이스북팀은 양방향이 아닌 **단방향을 데이터 흐름을 변경하는 것은 제안**하는데 이것이 `Flux 패턴`의 시작

<img width="887" alt="image" src="https://github.com/Book-Study-For-Developer/Modern-React-Deep-Dive/assets/27201591/f5374d49-5cb8-4245-9e2d-0c32863f315a">


- 액션 : **어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터**를 의미, 액션 타입과 데이터를 각각 정의해 이를 디스패치로 보낸다.
- 디스패처 : 액션을 스토어에 보내는 역할, 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- 스토어 : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있음, 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
- 뷰 : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것, 이 경우에는 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.

- 단방향 데이터 흐름 방식은 당연히 불편함도 존재한다. 사용자의 입력(사용자의 클릭)에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 코드이 양이 많아지고 개발자도 수고로워진다.
- 그러나 데이터의 흐름은 모두 액션이라는 한 방향(단방향)으로 줄어드므로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 한결 수월해진다.
- 리액트는 대표적인 단방향 데이터 바인딩을 기반을 한 라이브러리였으므로 이러한 단방향 흐름을 정의하는 `Flux 패턴`과 매우 궁합이 잘 맞다.
- 이와 동시에 이러한 `Flux 패턴`을 따르는 다양한 라이브러리가 우후죽순처럼 등장하기 시작했다.

### 시장 지배자 리덕스의 등장

- 리액트와 단방향 데이터 흐름이 점점 두각을 드러내던 와중에 등장한 것이 바로 리덕스
- 리덕스는 `Flux 구조`를 구현하기 위해 만들어진 라이브러리 중 하나이고 `Elm 아키텍처`를 도입
- `Elm`은 웹페이지를 선언적으로 작성하기 위한 언어

`Elm 아키텍처`의 핵심

- model : **애플리케이션의 상태**를 의미, `Model`을 의미하며 초기값으로 0
- view : **모델을 표현하는 HTML**을 의미, `Model`을 인수로 받아서 HTML을 표현
- update : **모델을 수정하는 방식**, `Increment`, `Decrement`를 선언해 각각의 방식이 어떻게 모델을 수정하는지 나타냄

- `Elm`은 `Flux`와 마찬가지로 데이터 흐름을 세가지로 분류
- 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력했다 →  리덕스는 `Elm 아키텍처`의 영향을 받아 작성됨
- 리덕스는 하나의 상태 객체를 스토어에 저장해두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행
- `reducer` 함수로 발생시킬 수 있는데 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파
- 하나의 전역 상태를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props를 깊이 전파해야 하는 이른바 prop 드릴링을 해결할 수 있었고, 스토어가 필요한 컴포넌트라며 단지 connect만 쓰면 스토어에 바로 접근할 수 있었다.

그렇다고 리덕스가 마냥 편하기만 한것은 아니었다.

- 단순히 하나의 상태를 바꾸고 싶어도 해야 할 일이 너무 많음 ex) 어떠한 액션인지 타입을 선언, 액션을 수행할 `creator` 함수 만들기, `dispatcher`과 `selector`필요 등
- 그럼에도 리액트와 리덕스는 일종의 표준처럼 굳어짐

### contextAPI와 useContext

단순히 상태를 참조하고싶을 뿐인데 리덕스는 준비해야하는 보일러플레이트가 부담스럽고 번거로워지고 결국에 제약으로 작용했다

리액트 16.3버전에서 새로운 `Context API`출시

`props`로 상태를 넘겨주지 않더라도 `Context API`를 사용하면 원하는 곳에서 `Context Provider`가 주입하는 상태를 사용할 수 있음

`Context API`는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다.

### **훅의 탄생, 그리고 React Query와 SWR**

- Context API가 선보인 지 1년이 채 되지 않아 리액트는 16.8 버전에서 **함수형 컴포넌트에 사용할수있는 다양한 훅 API를 추가**했다.
- 이 훅 API는 기존에 무상태 컴포넌트를 선언하기 위해서만 제한적으로 사용됐던 함수형 컴포넌트에 많은 기능을 제공했다.
- **state를 매우 손쉽게 재사용 가능**하도록 만들 수 있다는 것이다.

- **새로운 상태 관리 등장:** `React Query`, `SWR`
- 두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리
- API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리.

### **Recoil, Zustand, Jotai, Valtio에 이르기까지**

훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장하게 된다.

기존의 리덕스, MobX 등과 같은 라이브러리 차이점 : 애초에 리액트와의 연동을 전제로 작동해 별도로 다른 라이브러리를 설치하지 않아도 된다는 차이점

# 2. 리액트 훅으로 시작하는 상태 관리

## 1. 가장 기본적인 방법 : useState와 useReducer

`usestate` 의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성 및 관리할 수 있게 됐다

```jsx
function useCounter(initCount: number = 0) {
  const [counter, setCounter] = useState(initCount);

  function inc() {
    setCounter((prev) => prev + 1);
  }

  return { counter, inc };
}
```

`useCounter` 사용하는 함수 컴포넌트는 이 훅을 사용해 각자의 counter 변수를 관리하며, 중복되는 로직 없이 숫자를 1씩 증가시키는 기능을 손쉽게 이용

```jsx
function useCounter(initCount: number = 0) {
  const [counter, setCounter] = usestate(initCount);

  function inc() {
    setCounter((prev) => prev + 1);
  }

  return { counter, inc };
}

function Counter1() {
  const { counter, inc } = useCounter();

  return (
    <>
      <h3>Counter1: {counter}</h3>
      <button onclick={inc}>+</button>
    </>
  );
}

function Counter2() {
  const { counter, inc } = useCounter();
  return (
    <>
      <h3>Counter2: {counter} </h3>
      <button onclick={inc}>+</button>
    </>
  );
}
```

- `useCounter`라는 훅이 없었다면 이러한 기능이 필요한 각각의 컴포년트에서 모두 위와 같은 내용을 구현해야만 했을 것이다
- 훅으로 코드를 격리해 제공할 수 있다는 장점 , 훅을 기반으로 만든 사용자 정의 훅은 함수형 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점
- `useState`와 비슷한 훅인 `useReducer` 또한 마찬가지로 지역 상태를 관리할수 있는 훅

- 실제로 `useState`는 `useReducer`로 구현 → `useState`나 `useReducer` 모두 약간의 구현상의 차이만 있을 뿐, 두 훅 모두 지역 상태 관리를 위해 만들어졌다.
- 이 둘은 상태 관리의 모든 필요성과 문제를 해결해 주지는 않는다.
- 훅을 사용할 때마다 컴포넌트 별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.
- 위 예제의 경우 `counter`는 `useCounter`이 선언될 때마다 새롭게 초기화 되어, 컴포넌트별로 상태의 파편화를 만들어 버린다.

지역 상태(local state)는 기본적인 `useState`를 기반으로 한 상태를 라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

`useCounter` 제공하는 `counter`를 올리는 함수는 동일하게 사용하되, 두 컴포넌트가 동일한`counter` 상태를 바라보게 하기 위해서는 어떻게 해야할까?

- 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 상태를 컴포넌트 밖으로 한 단계 끌어 올리는 것이다.

## 2. **지역 상태의 한계를 벗어나보자 useState의 상태를 바깥으로 분리하기**

useState의 명확한 한계 : 해당 컴포넌트에서만 사용 가능

새로운 상태를 사용자의 UI에 보여주기 위해서는 반드시 리렌더링이 필요하다

**리렌더링을 하기 위해서는 다음 작업 중 하나가 일어나야 한다.**

1. useState, useReducer의 반환값 중 두 번째 인수 호출된다.
2. 부모 함수가 리렌더링 되거나 해당 함수가 다시 실행돼야 한다. 

useState 초깃값으로 컴포넌트 외부 값 사용시 문제점

- 렌더링을 위해서만 내부에 외부와 동일한 상태가 있음. 중복 관리라는 비효율.
- 각 컴포넌트가 비정상적 작동. 다른쪽은 리렌더링 되지 않고 버튼을 눌러야만 최신값 불러옴. 다른쪽에는 리렌더링을 일으킬 무언가가 없기 때문.

함수 외부에서 상태를 참조하고 렌더링까지 자연스럽게 일어나려면?

- 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 함
- 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고, 변화될 때마다 리렌더링이 일어나 최신 상태값 기준으로 렌더링해야 함. 이는 이 상태를 참조하는 `모든` 컴포넌트에서 동일 작동해야 함
- 상태가 원시값이 아닌 객체인 경우, 감지하지 않는 값이 변해도 리렌더링이 발생해서는 안된다. 
`{ a: 1, b: 2}`의 a를 업데이트 했다고 b만 참조하는 컴포넌트에서 리렌더링을 일으켜서는 안된다.

## 3. **useState와 Context를 동시에 사용해 보기**

훅을 사용하는 서로 다른 스코프에서 스토어의 구조는 동일하되, 여러개의 서로다른 데이터를 공유해 사용하고 싶다면 Context 를 활용해 해당 스토어를 하위 컴포넌트에 주입한다면 컴포넌트에서는 자신이 주입된 스토에 대해서만 접근할 수 있게 된다.

## 4. **상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기**

사용법은 각 웹 사이트를 참고하는게 좋을 것 같습니다.
