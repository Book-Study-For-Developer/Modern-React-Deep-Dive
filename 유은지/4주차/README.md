# 서버 사이드 렌더링이란?

## 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 애플리케이션이란?

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 최초의 페이지에서 데이터를 불러온 이후 페이지 전환은 자바스크립트와 브라우저의  `history.pushState` 와 `history.replaceState` 로 이뤄진다
- 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다
- 최초 로딩해야 할 자바스크립트 리소스가 크지만 한번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다

### **전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교**

- 서버 사이드
    - 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱하는 작업으 거친다
    - 페이지를 처음부터 새로 그려야 해서 일부 사용자는 페이지가 전환될 때 부자연스러운 모습을 보게 된다
- 클라이언트 사이드
    - 최초에 한번 모든 리소스를 다운로드하고 나면 이후 페이지를 전환할 때 추가로 리소스를 다운로드하는 시간이 필요 없어진다
    - 페이지 전체를 새로 렌더링하는 것이 아니라 페이지 전환에 필요한 일부 영역만 다시 그리게 되므로 훨씬 더 매끄러운 UI를 보여줄 수 있게 된다

## 서버 사이드 렌더링

### 장점

1. 최초 페이지 진입이 비교적 빠르다
2. 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다
3. 누적 레이아웃 이동이 적다
4. 사용자 디바이스 성능에 비교적 자유롭다
5. 보안에 좀 더 안전하다

### 단점

1. 소스코드를 작성할 떄 항상 서버를 고려해야 한다
2. 적절한 서버가 구축돼 있어야 한다
3. 서비스 지연에 다른 문제 

## **SPA와 SSR을 모두 알아야 하는 이유**

### **싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션**

싱글 페이지

- 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 애플리케이션보다 낫다
- 최초 페이지 진입시에 보여저할 정보만 최적화해 요청해서 렌더링
- 이미지와 같은 중요성이 떨어지는 리소스는 게으른 로딩으로 렌더링에 방해되지 않도록 처리
- 코드 분할을 통해 불필요한 자바스크립트 리소스의 다운로드 및 실행을 방지
- 라우팅이 발생하면 변경이 필요한 HTML 영역만 교체
- 싱글 페이지 애플리케이션은 렌더링과 라우팅에 최적화가 돼 있지 않다면 사용자 기기에 따라 성능이 들쑥날쑥, 적절한 성능 최적화도 돼 있지 않을 수 있다

멀티 페이지

- 멀티 페이지 애플리케이션은 매번 서버에 렌더링을 요청하고, 서버는 안정적인 리소스를 기반으로 매 요청마다 비슷한 성능의 렌더링을 수행한다
- 멀티 애플리케이션에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 API가 브라우저에 추가되고 있다
- 페인트 홀딩 : 같은 출저에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
- back forward cache(bfcache) : 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
- Shared Element Transitions : 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법****

### **현대의 서버 사이드 렌더링**

최초 웹 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 싱글 페이지 애플리케이션처럼 작동

# 서버 사이드 렌더링을 위한 리액트 API 살펴보기

## **renderToString**

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- useEffect와 같은 훅과 handleClick과 같은 이벤트 핸들러는 결과물에 포함되지 않음
- 인수로 주어진 리액트 컴포넌트를 기준으로 빠르게 브라우저가 렌더링할 수 있는 HTML을 제공하기 위한 함수
- 사용자와 인터랙션할 준비가 되기 위해서는 이와 관련된 자바스크립트 코드를 모두 다운로드, 파싱, 실행하는 과정을 거쳐야함

## **renderToStaticMarkup**

- renderToString과 매우 유사하지만, data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다는 차이점이다
- HTML의 크기를 아주 약간 줄일 수 있다****
- 하지만 리액트의 이벤트 리스너를 등록하는 hydrate 수행불가능

## **renderToNodeStream**

- renderToString과 renderToStaticMarkup과 달리 브라우저에서 실행 불가능
- 문자열이 아닌 Node.js의 ReadableStream을 반환한다
- 큰 크기의 데이터를 청크 단위로 분리해 조금씩 가져와 순차적으로 처리할 수 있다
- 대부분의 리액트 서버 사이드 렌더링 프레임워크는 모두 renderToNodeStream을 채택한다

## **renderToStaticNodeStream**

- 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않음
- hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드****

## **hydrate**

- renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할
- 컴포넌트와 HTML의 요소를 인수를 받아 HTML의 요소에 해당 컴포넌트를 렌더링하며, 이벤트 핸들러를 붙이는 작업까지 한번에 수행하는 render 함수
