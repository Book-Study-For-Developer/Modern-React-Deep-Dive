# 2장  리액트 핵심 요소 살펴보기

# 1. JSX란?

- 페이스북이 임의로 만든 새로운 문법
- 트랜스파일러를 거쳐 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환해야 한다
- XML 스타일의 트리 구문을 작성하는 데 도움을 주는 문법이다

## JSX의 정의

- `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXString` 4가지 컴포넌트를 기반으로 구성돼 있다
- `JSXElement` : HTML 요소와 비슷한 역할을 한다
- `JSXAttributes` : `JSXElement` 에 부여할 수 있는 속성, 필수값 아니다
- `JSXChildren` : `JSXElement` 의 자식 값을 나타낸다
- `JSXString` : JSX 문법을 사용하여 작성된 문자열이다

---

# 2. 가상 DOM과 리액트 파이버

## 가상 DOM의 탄생 배경

- 웹 페이지를 렌더링 하는 과정은 매우 복잡, 비용이 많이 든다
- 인터렉션을 통해 다양한 정보도 노출된다
- DOM을 관리하는 과정에서 부담해야 할 비용이 커진다
- 따라서, 가상 DOM은 실제 DOM의 잦은 조작으로 인한 성능 문제를 해결하기 위해 등장했다
- 가상 DOM은 웹 페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다

## 가상 DOM을 위한 아키텍처, 리액트 파이버

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이다
- 리액트에서 관리하는 평범한 자바스크립트 객체이다.
- 파이버는 파이버 재조정자(fiiber reconciler)가 관리한다
- DOM을 비교해 변경 사항을 수집하여, 둘 사이에 차이가 있으면 관련 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다. → 재조정 알고리즘

### 리액트 파이버 목표

- 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다
- 하는 일
    - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다
    - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다
- 이 과정이 비동기로 일어난다

### 파이버 구현

- 파이버는 하나의 작업 단위로 구성되어 있다.
- 작업 단위를 하나씩 처리하고 `finishedWork()` 라는 작업으로 마무리한다. 그리고 이 작업 사항을 커밋해 실제 브라우저 DOM에 가시적인 변경사항을 만들어 낸다.
1. 랜더 단계에서 리액트는 리액트 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 DOM에 실제 변경 사항을 반영하기 위한 작업인 `commitWork()` 가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.
- 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나, DOM의 변경이 필요한 시점 등에 실행된다
- 리액트가 파이버를 처리할 때마다 이런 작업을 직접 처리 혹은 스케줄링 하기도 한다

### 리액트 파이버 트리

- 더블 버퍼링을 사용한다
    - 현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리
    - 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress트리를 현재 트리로 바꾼다
- 커밋단계에서 수행

### 파이버의 작업 순서

1. `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다
2. 작업이 끝나면 그 다음 completeWork() 함수를 실행해 파이버 작업을 완료한다
3. 형제가 있다면 형제로 넘어간다
4. 2번, 3번 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음

setState로 인한 업데이트 요청이 생기면 workInProgress트리를 다시 빌드하고 파이버가 이미 존재하니깐 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다

### 파이버와 가상 DOM

즉, 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이고 비동기로 이뤄진다. 

DOM에 반영하는 것은 동기적으로 일어나야 하고 메모리 상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

---

# 클래스형 컴포넌트와 함수형 컴포넌트

## 클래스형 컴포넌트

### 클래스형 컴포넌트의 생명주기 메서드

- 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

`**render()**`

컴포넌트가 UI를 렌더링하기 위해 쓰인다. 마운트와 업데이트 과정에서 일어난다

주의할 것은 항상 순수해야 하며 부수효과가 없어야 한다. 즉, 같은 입력값(props or state)이 들어가면 항상 같은 결과물을 반환해야 한다.

**`componentDidMount()`**

컴포넌트가 마운트되고 준비가 되면 그 다음으로 호출하는 메서드이다.

**`componentDidUpdate()`**

컴포넌트 업데이트가 일어난 이후 바로 실행된다

**`componentWillUnmount()`**

컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.

메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치이다.

**`shouldComponentUpdate()`**

state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용한다.

**`static** **getDerivedStateFromProps()**`

render()를 호출하기 직전에 호출된다.

반환되는 객체는 해당 객체의 내용이 모두 state로 들어가게 된다.

**`getSnapShotBeforeUpdate()`**

DOM이 업데이트되기 직전에 호출된다. 

DOM에 렌더링되기 전에 윈도우 크기 조절, 스크롤 위치 조정 등 작업 처리에 유용하다.

**`getDerivedStateFromError()`**

자식 컴포넌트에 에러 상황에 발생했을 때 호출되는 에러 메서드이다.

**`componentDidCatch()`**

자식 컴포넌트에서 에러가 발생했을 때 실행된다 `getDerivedStateFromError` ****에서 에러를 잡고 state를 결정한 이후에 실행된다.

`ErrorBoundary` 를 만들기 위한 목적으로 많이 사용된다

### 클래스 컴포넌의 한계

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 얼벼다
- 기능이 많아질수록 컴포넌트 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 코드 크기를 최적화 하기 어렵다
- 최종 결과물인 번들 크기 줄이는 것이 어렵다
- 핫 리로딩을 하는데 상대적으로 불리하다 (핫 리로딩 : 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법)

## 함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기의 부재
- 함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다

---

# 렌더링은 어떻게 일어나는가?

## 리액트의 렌더링이란?

리액트에서 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM결과를 브라우저에게 제공할 것인지 계산하는 일련의 과정을 의마한다.

## 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링
    1. 사용자가 처음 애플리케이션에 진입하면 렌더링할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다
2. 리렌더링
    1. 최초 이후의 모든 렌더랑을 의미한다
    2. 클래스형 컴포넌트 → setState, forceUpdate가 실행되는 경우
    3. 함수형 컴포넌트 →useState()의 setter, useReducer()의 dispatch가 실행되는 경우
    4. 컴포넌트의 key props가 변경되는 경우
        1. current트리와 workingInProgress가 key를 통해 구별한다
    5. props가 변경되는 경우
    6. 부모 컴포넌트가 렌더링 되는 경우
    

## 리액트의 렌더링 프로세스

리액트 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

업데이트가 필요하다고 지정돼 있는 컴포넌트 발견하면

- 클래스형 컴포넌트의 경우 클래스 내부의 render()함수를 실행함
- 한수형 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출하고 결과물을 저장

렌더링 프로세스가 실행되면서 과정을 거쳐 각 컴포넌트의 렌더링 결과를 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례라례 수집한다.

이 과정이 재조정 과정이고, 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 한다.

## 렌더와 커밋

**렌더 단계**

- 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
- 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
- 비교하는 것 : `type` , `props`, `key` (하나라도 변경된 것이 있으면 변경된 컴포넌트로 체크됨)

**커밋 단계**

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- 이 과정이 끝나야 브라우저 렌더링이 발생한다
- 리액트가 먼저 DOM의 커밋 단계에서 업데이트 한다면 이렇게 만ㄷ르어진 모든 DOM 노드 및 인스턴스를 가르키도록 내부의 참조를 업데이트함
- 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는게 아니다
- 렌더링을 수행했으나 커밋단계까지 갈 필요 없으면 커밋 단계 생략가능

두 가지 과정으로 리액트 렌더링은 항상 동기식으로 작동함 → 렌더링 길수록 성능 저하

따라서 동시성 렌더링 등장 → 비동기 렌더링, 특정 렌더링의 우선순위를 낮추거나 필요하다마녀 중단하거나 재시작하거나 경우에 따라서 포기할 수 있음

---

# 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

고차 컴포넌트인 memo, useMemo 훅, useCallback 훅는 최적화 기법에 사용됨

메모이제이션을 통해 언제 최적화를 할지?에 대한 주장들.

## 1. 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션은 비용이 든다.

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전 결과물을 저장해 두었다가 다시 꺼내와야 하는 비용

근데 과연 메모이제이션 비용이 리렌더링 비용보다 저렴한가?

→ 상황에 따라 다르기에 섣부른 최적화를 경계해라

따라서 메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이다.

리액트 공식문서에서도 usMemo의 성능 최적화를 계속 제공해준다는 보장이 없다라고 나와있다.

→ useEffect로 어떻게 렌더링이 일어나고 있는 지 확인하고 필요한 곳에서만 최적화해라

## 2. 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

일부 컴포넌트는 메모이제이션을 하는 것이 성능에 도움이 된다

**memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법**

→ 개발자가 많아지고 컴포넌트의 복잡성이 증가하면 이 방법은 적용할 수 없다

**memo를 일단 그냥 다 적용하는 방법**

→ 적절하지 않은 컴포넌트에 memo를 적용했을 때 지불해야하는 비용은 무엇일까?

- props에 대한 얕은 비교

반면 memo를 하지 않았을 때의 문제점 

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리구 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신 트리를 비교

결론 

- 메모이제이션은 이점이 많다.
