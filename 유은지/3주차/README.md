# `useState`

함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅

내부는 **클로저**로 구현이 되어 있다

### 게으른 초기화

`useState`  에 변수 대신 함수를 넘기는 것

초기값이 복잡, 무거운 연산 포함 시 사용 권장 (리액트 공식문서)

인수로 넘겨진 함수는 컴포넌트가 처음 렌더링 될 때 단 한 번만 실행(상태가 처음 생성될 때만 실행)된다. 리렌더링 시에는 이미 초기 상태가 설정되어 있기 때문에, 함수가 다시 호출되지 않는다.(이전 상태를 재사용)

ex) localStorage, sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근 혹은 초기값 계산을 위해 함수 호출 

> [그냥 함수를 넣었을 때와의 차이점](https://velog.io/@samkong/Lazy-initialization)
> 

## `useEffect`

생명 주기를 대체하기 위한 훅 ❌

**useEffect란?**

렌더링할 때마다 의존성에 있는 값을 보면서 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수

**클린업 함수의 목적**

본문 함수 내에서 어떤 작업을 수행한 후에 이를 정리해야 하는 경우가 있다. 예를 들어, 이벤트 리스너를 추가하거나, 타이머를 설정하는 등의 작업이 이에 해당한다.

함수형 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 즉 이전 상태를 청소해 주는 개념이다.

**의존성 배열**

의존성 배열이 없이 쓰는 거는 그냥 없어도 되는거 아닐까? → 차이점이 존재

- 서버 사이드 렌더링 관점에서 `useEffect`는 **클라이언트 사이드에서 실행되는 것이 보장**된다. `useEffect` 내부에서는 window 객체의 접근에 의존하는 코드 사용이 가능하다.
- `useEffect` 는 컴포넌트 렌더링의 부수 효과, 즉 **컴포넌트 렌더링이 완료된 이후**에 실행된다. 반면 직접 실행은 컴폰너트가 렌더링 되는 도중에  실행된다. 따라서 위와 달리 서버 사이드 렌더링의 경우 서버에서도 실행된다. 그리고 이 작업은 함수형 컴폰넌트의 반환을 지연시키는 행위다. 즉, 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다

→ `useEffect` 는 컴포넌트가 렌더링된 후에 어떠한 부수효과를 일으키고 싶을 때 사용하는 훅이다

### `useEffect` 사용시 주의할 점

1. **eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라**
    - 훅에 누락된 종속성이 있을 때 경고를 띄운다 (배열에 빈 값)
    - 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅
2. `**useEffect` 의 첫 번째 인수에 함수명을 부여하라**
3. **거대한 `useEffect`를 만들지 마라**
4. 불필요한 외부 함수를 만들지 마라

> useEffect의 경쟁 상태

여러 개의 비동기 작업이 동시에 진행되어 그 결과가 작업이 시작된 순서와는 다른 순서로 도착하는 상황
> 

# `useMemo`

비용이 큰 연산에 대한 결과를 저장해두고 이 저장된 값을 반환하는 훅이다.

## `useCallback`

useMemo가 값을 기억한다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다.

즉, 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미다.

함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 떄 사용한다.

**useMemo와의 차이점**

메모이제이션하는 대상이 변수(useMemo)냐 함수(useCallback)냐 차이일 뿐

## `useRef`

`useState` 와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다.

그러나 큰 차이점은 2가지가 있다.

- `useRef` 는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다
- `useRef` 는 그 값이 변하더라도 렌더링을 발생시키지 않는다

**기존 리액트식 접근의 문제점**

- 컴포넌트가 실행되어 렌더링 되지 않았음에도 불필요한 메모리 사용
- 컴포넌트가 여러 번 생성되면 내부에 있는 값이 인스턴스마다 1개씩 생긴다

`useRef` 는 최초에 넘겨받은 기본값을 가지고 있다 → return 문의 DOM이 아니라 useRef()로 넘겨받은 인수임

```jsx
function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
        ref.current = value;
    }, []);

    return ref.current;
}

function SomeComponent() {
    const [counter, setCounter] = useState(0);
    const previousCounter = usePrevious(counter);

    function handleClick() {
        setCounter((prev) => prev + 1);
    }

    // 0 undefined
    // 1, 0
    // 2, 1
		// 3, 
    return (
        <button onClick={handleClick}>
            {counter} {previousCounter}
        </button>
    );
}
```

[https://velog.io/@yukyung/React-제어-컴포넌트와-비제어-컴포넌트의-차이점-톺아보기](https://velog.io/@yukyung/React-%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0)

## `useContext`

콘텍스트와 해당 콘텍스트를 함수형 컴포넌트에서 사용할 수 있게 해주는 훅

### Context란?

props를 전달 없이도 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값을 사용할 수 있음

### 주의할 점

- `useContext` 를 함수형 컴포넌트 내부에서 사용할 때 컴포넌트 재활용이 어려워진다
- Provider에 의존성을 가지고 있는 셈이 되므로 아무데서나 재활용하기에는 어려운 컴포넌트가 된다
- 이를 방지하기 위해서 `useContext`를 사용하는 컴포넌트를 최대한 작게 하거나 혹은 재사용되지 않을 만한 컴포넌트에서 사용하기. 즉 최대한 좁게 만들기
- 상태관리를 위한 API가 아니라 상태를 주입해 주는 API이다

상태관리위한 API를 위한 조건

- 어떠한 상태를 기반으로 다른 상태를 만들어낼 수 있어야 한다
- 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 한다

## `useReducer`

useState의 심화 버전.

목적은 복잡한 형태의 state를 사전에 정의된 dispatcher로만 수정할 수 있게 만들어 줌으로써 state 값에 대한 접근은 컴포넌트에서만 가능하게 하고, 이를 업데이트하는 방법에 대한 상세 정의는 컴폰넌트 밖에 둔 다음, state의 업데이트를 미리 정의해둔 dispatcher로만 제한하는 것이다.

## `useImperativeHandle`

### forwardRef 살펴보기

ref는 useRef에서 반환한 객체이다. 이를 상위 컴포넌트에서 하위 컴포넌트로 전달하고 싶을 때 사용한다. 그냥 ref를 던잘할 수 있지만 일관성을 제공하기 위해 사용한다. 어떤 props명으로 전달할지 모르고, 이에 대한 완전한 네이밍의 자유가 주어진 props보다는 forwardRef를 사용하면 좀 더 확실하게 ref를 전달할 것임을 예측할 수 있고, 또 사용하는 쪽에서도 확실히 안정적으로 받아서 사용가능하다.

### useImperativeHandle 란?

부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅

## `useLayoutEffect`

useEffect와 동일하나 모든 DOM의 변경(렌더링) 후에 동기적으로 발생한다.

실행 순서

1. 리액트가 돔을 업데이트
2. `useLayoutEffect` 를 실행
3. 브라우저에 변경사항을 반영
4. `useEffect`를 실행

동기적으로 발생한다는 것은 리액트는 `useLayoutEffect`의 실행이 종료될 때까지 기다린 다음에 화면을 그린다는 것

DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용하는 것이 좋다 (특정 요소에 따라 돔 요소를 기반으로 한 애니메이션, 스크롤 위치를 제어하는 등 화면에 반영되기 전에 하고 싶은 작업)\

## `useDebugValue`

리액트 애플리케이션을 개발하는 과정에서 사용하는데, 디버깅하고 싶은 정보를 이 훅에다가 사용하면 리액트 개발자 도구에서 볼 수 있다. 

사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅

## 훅의 규칙

1. 최상위에서만 훅을 호출해야 한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야만 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
2. 훅을 호출할 수 있는 것은 리액트 함수형 컴포너트 , 혹은 사용자 정의 훅의 두 가지 경우뿐이다. 일반 자바스크립트에서는 훅을 사용할 수 없다.

리액트 훅은 파이버 객체의 링크드 리스트의 호출 순서에 따라 저장된다. 따라서 조건문, 반복문 등에 의해 리액트에서 예측 불가능한 순서로 실행되게 해서는 안 된다.

# 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

## 사용자 정의 훅

서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용되는 것

## 고차 컴포너트

컴포넌트 자체의 로직을 재사용하기 위한 방법이다. 리액트의 고차 컴포넌트는 `React.memo` 이다.

### 고차함수 만들어보기

리액트의 함수형 컴포넌트도 함수이기 때문에 함수를 기반으로 고차 함수를 만드는 것을 먼저 이해해야 한다.

고차 함수의 사전적인 정의를 살펴보면 ‘함수를 인수로 받거나 결과로 반환하는 함수’로 정의돼 있다.

```jsx
// 즉시 실행 함수로 setter를 만든다.
const setState = (function () {
		// 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에
		// 접근할 수 있도록 한다.
    let currentIndex = index;

    return function (value) {
        global.states[currentInex] = value;
				// 컴포넌트를 렌더링한다.
    };
})();
```

고차 함수를 사용하면 함수를 인수로 받거나, 새로운 함수를 반환해 완전히 새로운 결과를 만들어낼 수 있다. 따라서, 다양한 작업을 할 수 있다.

### 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기

```jsx
interface LoginProps{
	loginRequired?: boolean
}

function withLoginComponent<T>(Component: ComponentType<T>) {
	return function (props: T & LoginProps) {
		const { loginRequired, ...restProps } = props

		if(loginRequired){
				return <>로그인이 필요합니다.</>
		}

		return <Component {...(restprops as T)} />
	}
}

// 원래 구현하고자 하는 컴포넌트를 만들고, withLoginComponent로 감싸기만 하면 끝이다.
// 로그인 여부, 로그인이 안 되면 다른 컴포넌트를 렌더링하는 책임은 모두
// 고차 컴포넌트인 withLoginComponent에 맡길 수 있어 매우 편리하다.
const Component = withLoginComponent((props: { value: string }) => {
    return <h3>{props.value}</h3>;
});

function App() {
    const isLogin = true;

    return <Component value="text" loginRequired={isLogin} />;
}
```

고차 컴포넌트는 컴포넌트 전체를 감쌀 수 있다는 점에서 사용자 정의 훅보다 더욱 큰 영향력을 컴포넌트에 미칠 수있다. 단순히 값을 반환하거나 부수 효과를 실행하는 사용자 정의 훅과는 다르게, 고차 컴포넌트는 컴포넌트의 결과물에 영향을 미칠 수 있다는 다른 공통된 작업을 처리할 수 있다.

`with` 로 시작하는 이름을 사용해야 한다.

**주의할 점**

- 부수 효과를 최소화해야 한다.
- 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다.

## 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 사용자 정의 훅이 필요한 경우

단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 취하게 하고 싶다면 사용자 정의 훅을 사용해라. 사용자 정의 훅 자체는 렌더링에 영향을 미치지 못하기 때문에 사용이 제한적이므로 반환하는 값을 바탕으로 무엇을 할지는 개발자에게 달려 있다.

따라서 컴포넌트 내부에 미치는 영향을 최소화해 개발자가 훅을 원하는 방향으로만 사용할 수 있다.

### 고차 컴포넌트를 사용해야 하는 경우

함수형 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하자.
