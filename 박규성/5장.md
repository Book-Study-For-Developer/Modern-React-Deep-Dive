# 5장 : 리액트와 상태 관리 라이브러리

웹 애플리케이션을 개발할 떄 이야기하는 상태는, 어떠한 의미를 가진 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

프레임워크를 지향하는 Angular와는 다르게 리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐, 그 이상의 기능을 제공하지 않는다.

### Flux패턴

- Action : 어떠한 작업을 처리할 액션과, 그 액션 발생 시 함께 포함시킬 데이터
- Dispatcher : 액션을 소토어에 보내는 역할
- Store : 실제 상태에 따른 값과, 상태를 변경할 수 있는 메서드를 가짐
- View : 스토어에서 만들어진 데이터를 가져와 화면에 렌더링 하는 역할

### Redux

리액트와 단방향 데이터 흐름이 점점 두각을 드러내는 와중 등장했다.

- 하고자 하는 일에 비해 보일러플레이트가 너무 많다는 비판의 목소리

### Context와 useContext

상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않아 사용할 때 주의가 필요하다. 즉, props drilling을 해결하기 위해 등장한 것

### React Query와 SWR

- fetch를 관리하는 데 특화된 라이브러리
- API 호출에 대한 상태를 관리하기에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

### useState와 useReducer

선언될 때마다 새롭게 초기화되어, 결론적으로 컴포넌트별로 상태의 파편화를 만들게 된다.

지역상태라는 한계 때문에 여러 컴포넌트에 걸쳐 공유하기 위해서는 컴포넌트 트리를 재설계하는 등의 수고로움이 필요하다.

useState나 useReducer를 사용하지 않고 직접 변수를 만들어 사용한다면, 리렌더링의 조건(useState,useReducer의 반환값 중 두번째 인수/부모 컴포넌트의 리렌더링 등)에 성립하지 않기 때문에 리렌더링이 발생하지 않는다.

- Set은 자료형에 관계없이 유일한 값을 저장할 수 있다.
- useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다. 이는 컴포넌트의 최상단 내지는 상태가 필요한 부모가 될 수 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.

## Recoil, Zustand, Jotai, Valtio

: 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었고, 훅을 지원함으로써 함수형 컴포넌트에서 손쉽게 사용할 수 있다.

- Recoil, Jotai : Context, Provider, 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데에 초점을 맞추고 있다
- Zustand : 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리
    - Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알린다.

### 1. Recoil

- 페이스북에서 만든 리액트를 위한 상태 관리 라이브러리
- 최소 상태 개념인 Atom을 처음 리액트 생태계에 선보임
- 정식으로 출시한 라이브러리가 아니라 실험적으로 개발되고 운영되는 라이브러리
    - 실제 프로덕션에서 사용하기에는 안정성이나 성능, 사용성 등을 보장할 수 없다.
- RecoilRoot
    - Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
    - 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값은 변경할 수 있다.
    - 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.