# 2. 리액트 핵심 요소 깊게 살펴보기

## 1. JSX란?

JSX는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다. 

JSX는 HTML이나 XML을 자바스크립트 내부에 표현하는 것이 유일한 목적이 아니다. JSX의 설계목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조로 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.

### 1. JSXElement

: JSX를 구성하는 가장 기본 요소로, HTML의 요소와 비슷한 역할을 한다.

1. JSXOpeningElement 
    - `<JSXElement>`
2. JSXClosingElement
    - `<JSXElement />`
3. JSXSelfClosingElement
    - `<JSXElement />`
4. JSXFragment
    - `<>JSXChildren</>`

JSXElementName : JSXElement의 요소 이름으로 쓸 수 있는 것

1. JSXIdentifier : JSX내부에서 사용할 수 있는 식별자
    - 숫자로 시작하거나, $와 _같은 특수문자 사용 불가
2. JSXNamespacedName : `JSXIdentifier:JSXIdentifier`의 조합
    - `:` 을 통해 서로 다른 식별자를 이어주는 것
        
        ```tsx
        function valid(){
        	return <foo:bar></foo:bar>
        }
        ```
        
3. JSXMemberExpression : `JSXIdentifier.JSXIdentifier`의 조합
    - .을 통해 서로 다른 식별자를 이어주는 것
        
        ```tsx
        function valid(){
        	return <foo.bar></foo.bar>
        }
        ```
        

### 2. JSXAttributes

: JSXElement에 부여할 수 있는 속성

1. JSXSpreadAttributes : 자바스크립트의 전개 연산자와 동일한 역할
    - `{…AssignmentExpression}`
2. JSXAttribute : 속성을 나타내는 키와 값으로 짝을 이루어서 표현
    1. JSXAttributeName : 속성의 키 값
        - JSXNamespacedName와 JSXMemberExpression도 가능
    2. JSXAttributeValue : 속성의 키에 할당할 수 있는 값
        1. “큰 따옴표로 구성된 문자열”
        2. ‘작은 따옴표로 구성된 문자열’
        3. { AssignmentExpression }

### 3. JSXChildren

: JSXElement의 자식 값

- JSXChild : JSXChildren을 이루는 기본 단위이다.
    - JSXText
    - JSXElement
    - JSXFragment

### 4. JSXStrings

: 큰 따옴표로 구성된 문자열, 

### 2. JSX는 어떻게 자바스크립트에서 변환될까?

JSX를 변환하는 `@babel/plugin-transform-react-jsx`플러그인을 알아야 한다. 이는 JSX꾸문을 자바스크립트가 이해할 수 있는 형태로 변환한다.

```tsx
const componentA = <A required>Hello World</A>
```

```tsx
const componentA = React.createElement(
	A,{required:true},"Hello World"
)
```

리액트 17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 트랜스파일한 결과는 조 금그르다.

때에 따라서는 직접 createElement를 사용해 컴포넌트를 구성하는 편이 더 효율적일 수 있다.

## 2. 가상 DOM과 리액트 파이버

DOM(Document Object Model) : 웹페이지에 대한 인터페이스로, 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

### 브라우저에서 화면을 보여주는 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS파일을 만나면 해당 CSS파일도 다운로드한다.
    
    ```tsx
    <link rel="stylesheet" type="text/css" href="./style.css" /> 
    ```
    
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 건 아니고 사용자 눈에 보이는 노드만 방문한다.
    - display:none과 같은 노드는 방문하지 않는다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM정보를 찾고 여기서 발견한 CSS스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 두 가지로 나눌 수 있다.
    1. 레이아웃(layout,reflow) : 각 노드가 브라우저 화면의 어떤 좌표에 정확히 나타나야 하는지 계산하는 과정
    2. 페인팅(painting) : 레이아웃 단계를 거 친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

### 가상 DOM

개발자는 인터랙션에 모든 DOM의 변경보다는 결과적으로 만들어지는 DOM 결과물 하나만 알고 싶을 것이다. 이러한 문제점을 해결하기 위해 탄생한 것이 바로 가상 DOM이다. 가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM이다. 

**가상 DOM**은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. 이러한 DOM 방식은 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다.

### 리액트 파이버

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체이다. 파이버 재조정자(fiber reconciler)가 관리한다. 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청한다.

**재조정** : 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

**파이버의 목표**는 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터페이스에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다. 이를 위해 파이버는 다음과 같은 일을 한다.

1. 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
2. 이러한 작업을 일시중지하고 나중에 다시 시작할 수 있다.
3. 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.

파이버는 일단 하나의 작업단위로 구성돼 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

1. **렌더 단계** : 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. **커밋 단계** : 앞서 언급한 DOM에 실제 변경사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다. 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

파이버의 객체 값에서도 알 수 있듯이, 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 변수에 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것이 바로 리액트다.

### 리액트 파이버 트리

리액트 내부에서 리액트 파이버 트리는 두 개 존재한다.

1. 파이버 트리 : 현재 모습을 담은 현재 트리
2. `workInProgress` 트리 : 작업 중인 상태를 나타내는 트리

1. 먼저, 현재 UI렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업이 시작된다.
2. 만약 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 workInProgress 트리를 빌드한다.
3. 이 workInProgress트리를 빌드하고 나면 다음 렌더링에 이 트리를 사용한다.
4. 이 workInProgress트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 current가 이 workInProgress로 변경된다.
- **더블 버퍼링** : 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법

### 파이버의 작업 순서

1. 리액트는 beginWork()함수를 실행해 파이버 작업ㅇ르 수행한다. 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번 작업이 끝나면 그 다음 completeWork()함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2,3번이 모두 끝나면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

최초 렌더링 시 위와같이 파이버를 만들지만, 그 이후는 이미 파이버가 존재하므로 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

### 파이버와 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 **파이버**이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. 이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하므고, 또 처리하는 작업이 많아 호면에 불완전하게 표시될 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

**가상 DOM과 리액트의 핵심**은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것이다,

## 2.3. 클래스형 컴포넌트와 함수형 컴포넌트

> 과거에는 모두 클래스형 컴포넌트로 작성이 되어있기에, 아얘 없어질 수는 없다. 그러므로 알아두면 좋다.
> 

### 클래스형 컴포넌트 예시

```tsx
class SampleComponent extends React.Component<SampleProps,SampleState>{
	private constructor(props:SampleProps){
		super(props);
		this.state = {
			count:0,
			isLimited:false
		}	
	}
	private handleClick = () => {
		const newValue = this.state.count + 1;
		this.setState({count:newValue, isLimited:newValue>=10});
	}
	public render(){
		const{
			props:{required,text},
			state:{count, isLimited},
		} = this
	}
	return (..)
}
```

1. constructor() : 컴포넌트가 초기화되는 시점에 호출
2. props : 컴포넌트에 특정 속성을 전달
3. state : 클래스형 컴포넌트 내부에서 관리하는 값
4. 메서드 : 렌더링 함수 내부에서 사용되는 함수
    - 보통 DODM에서 발생하는 이벤트와 함께 사용된다.

### 클래스형 컴포넌트의 생명주기 메서드

1. render () : 컴포넌트가 UI를 업데이트하기 위해 쓰인다.
    - 마운트 혹은 업데이트 과정에서 일어난다.
    - 순수하며, 부수 효과가 없어야 한다. 즉, 같은 입력값(props,state)에는 같은 결과물을 반환해야 한다.
2. componentDidMount() : 컴포넌트가 마운트되고 준비가 됐다면 그 다음 호출하는 메서드
    - UI를 업데이트하기 전에 실행되어 사용자가 변경된 것을 눈치챌 수 없게 한다.
3. componentDidUpdate() : 컴포넌트 업데이트가 일어난 이후 바로 실행
    - state, props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.
4. componentWillUnmount() : 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출
5. shouldComponentUpdate() : state, props의 변경으로 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용

---

1. static getDrivedStateFromProps() : render()를 호출하기 직전에 호출
    - componentWillRecieveProps를 대체
2. getSnapShotBeforeUpdate() : DOM 업데이트 되기 직전에 호출
    - componentWillUpdate 대체
3. getDerivedStateFromError() : 에러 상황에서 실행
4. componentDidCatch : 에러가 발생했을 때, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행

### 클래스형 컴포넌트의 한계

1. 데이터 흐름을 추적하기 어렵다.
2. 애플리케이션 내부 로직의 재사용이 어렵다.
3. 기능이 많아질수록 컴포넌트 크기가 커진다.
4. 함수형 컴포넌트에 비해 어렵다.
5. 핫 리로딩하는데 불리하다.

## 2.4 렌더링은 어떻게 일어나는가?

- 리액트의 렌더링은 브라우저의 렌더링과 다르다.
    
    **리액트에서의 렌더링**이란, 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM결과를 브라우저에 제공할 것인지 계산하는 일련의 과정
    

### 렌더링이 일어나는 경우

1. 최초 렌더링
2. 리렌더링
    1. 클래스형 컴포넌트의 setState 실행
    2. 클래스형 컴포넌트의 forceUpdate 실행
    3. 함수형 컴포넌트의 useState()의 두 번째 배열 요소인 setter 실행
    4. 함수형 컴포넌트의 useReducer의 두 번째 배열 요소인 dispatch 실행
    5. 컴포넌트의 key props가 변경되는 경우
        - **리액트에서 key**는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
        - 리렌더링이 발생하면 current트리와 workInProgress트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에서 같은 컴포넌틍니지를 구별하는 값이 바로 key이다.
            
            ```jsx
            <Child key={Math.random} />
            ```
            
        - 위처럼 매번 Key값이 바뀌는 경우, memo로 선언됐더라도 매번 리렌더링이 일어난다.
    6. Props가 변경되는 경우
    7. 부모 컴포넌트가 렌더링 될 경우

### 리액트의 렌더링 프로세스

1. **업데이트 감지**: 컴포넌트의 상태가 변경되었을 때, React는 이를 감지하고 업데이트가 필요한 컴포넌트를 결정합니다.
2. **렌더링 실행**: 업데이트가 필요한 컴포넌트의 **`render()`** 함수 또는 함수형 컴포넌트 자체가 실행되어 새로운 출력을 생성합니다.
3. **JSX 트랜스파일링**: JSX 코드는 JavaScript로 변환되며, **`React.createElement()`** 호출을 포함합니다.
4. **재조정과 가상 DOM**: 새로운 렌더링 결과를 가상 DOM에 반영하고, 이를 기존의 가상 DOM과 비교하여 변경 사항을 파악합니다.

### 렌더와 커밋

1. **렌더 단계**: 이는 첫 번째 단계에서의 '업데이트 감지'와 '렌더링 실행'에 해당합니다. 이 단계에서는 변경 사항을 계산하지만, 실제 DOM에는 아직 반영하지 않습니다.
    - type, props, key를 비교
2. **커밋 단계**: 여기서는 '재조정과 가상 DOM' 단계에 해당합니다. 계산된 변경 사항을 실제 DOM에 반영합니다. 이 단계 후에 **`useLayoutEffect`**와 **`useEffect`** 같은 훅이 실행됩니다.

이 두가지 과정으로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동한다. 왜냐하면, 비동기로 작동하면 뒤늦게 변경하는 것이 있어 사용자에게 혼란을 가져다 줄 수 있다.

커밋 단계를 거쳐서 DOM을 업데이트하고 나면, React는 요청된 DOM 노드와 컴포넌트 인스턴스를 가리키도록 모든 참조사항을 업데이트한다. 그러고나서 `useLayoutEffect`훅을 동기적으로 실행한다. 그 후 React는 짧은 타임 아웃을 세팅하고, 타임 아웃이 끝나면 모든 useEffect훅을 실행한다. 이 단계는 ‘수동적 효과’라고도 알려져 있다.

의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 이른바 동시성 렌더링이 리액트 18이 도입되었다. 동시성 렌더링은 렌더링 중 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라 포기할 수도 있다.

## 2.5 메모이제이션

1. useMemo
2. useCallback
3. memo

메모이제이션을 꼭 필요한 곳에서만 쓰자 vs 일단 쓰고 정말 불필요한 곳에서 쓰지 말자 의견이 첨예하게 갈린다. 저자의 의견은 이러하다. 

1. 이제 리액트를 배우고 있거나 리액트를 깊이 이해하고 싶고, 시간을 투자할 여유가 있는 사람 : 1번 의견대로 메모이제이션을 지양하는 자세를 견지하면서 실제로 어느 지점에서 성능상 이점을 누릴 수 있는 지 살펴보는식으로 메모이제이션 적용
2. 현업에서 리액트를 사용하거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 사람 : 일단 의심스러운 곳에는 먼저 다 적용해볼 것을 권장
    - lodash나 간단한 함수의 경우와는 다르게 일반적으로 props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다. 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다.
    - **useCallback**의 경우 다른 컴포넌트의 props로 넘어가는 경우가 많을 것이다. 이 Props로 넘어갔을 떄 참조 투명성을 유지하기 위해서는 UseCallback을 사용하는 것이 좋다.
    - **useMemo** 또한 마찬가지다. props로 넘어가거나 이를 활용할 여지가 있다면 사용하는 것이 좋다.
    - 성능에 대해서 지속적으로 모니터링하고 관찰하는 것보다 섣부른 메모이제이션 최적화가 주는 이점이 더 클 수도 있다.